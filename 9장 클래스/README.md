# 9장 클래스

- 자바스크립트의 클래스는 프로토타입 기반 상속을 사용한다.
    - 두 객체가 같은 프로토 타입에서 프로퍼티들을 상속한다면 이들을 같은 클래스의 인스턴스라고 부른다.
        - 두 객체가 같은 프로토타입을 상속한다면 일반적으로 같은 생성자 함수나 팩토리 함수를 통해 생성되고 초기화 되었을 확률이 높다.

> 자바스크립트의 클래스는 다른 객체지향언어(C++, 자바)의 고전적 클래스와 사뭇 다르다.
프로토 타입 기반 상속 메커니즘이 고전적 클래스 구현과 다르기 때문
> 

> 자바스크립트의 클래스는 예전부터 구현할 수 있었고, ES6에서 좀 더 클래스를 편하게 구현하도록 class 키워드를 지원했다.
> 

## 9.1 클래스와 프로토 타입

- 자바스크립트에서의 클래스는 같은 프로토타입 객체에서 프로퍼티를 상속하는 객체 집합이다.
    - 따라서 프로토 타입 객체가 클래스의 핵심 기능
- 클래스의 메서드는 this 키워드를 써서 자신이 호출된 객체를 참조하는 방식으로 해당 프로퍼티에 접근한다.
    - 이는 모든 클래스 메서드의 기본적인 특징이다.
    

---

## 9.2 클래스와 생성자

- 클래스의 생성자는 새로 생성된 객체를 초기화하도록 설계된 함수이다.
    - 생성자는 new 키워드를 사용하여 호출한다.
    - 생성자 자체에서 할일은 새 객체의 상태를 초기화 하는것 뿐이다.
        - 생성자 호출에서 중요한 특징은, 생성자의 prototype 프로퍼티가 새 객체의 프로토타입으로 사용된다는 것이다.

- 생성자 함수를 공유하는 객체는 모두 같은 객체를 상속하며, 같은 클래스의 멤버이다.
- 생성자를 호출하면, 자동으로 새 객체가 생성되고, 생성자를 그 객체의 메서드로 호출하며, 새 객체를 반환한다.

> **ES6의 클래스 문법은 화살표 함수로 메서드를 정의하는 것올 허용하지
않으므로 실수할 가능성은 없습니다.**라고 하는데 가능한거 같아 의문이다.
> 

### 9.2.2 생성자 프로퍼티

- 화살표함수, 제너레이터 함수, 비동기 함수를 포함에 일반적인 자바스크립트 함수는 모두 생성자로 사용될 수 있다.
    - 생성자를 호출할때는 prototype 프로퍼티가 필요함으로 일반적인 자바스크립트 함수는 모두 자동으로 prototype 프로퍼티를 갖는다.
    

## 9.3 class 키워드를 사용하는 클래스

- `use strict` 지시자가 없어도 class 선언의 바디는 모두 묵시적으로 스트릭트 모드로 동작한다.
    - 따라서 8진수 정수 리터럴이나 with문을 사용할 수 없으며, 변수를 사용하기 전에 선언하지 않으면 문법 에러가 일어난ㄴ다.
- 함수 선언과 달리 클래스 선언은 끌어올려지지 않기 때문에 클래스를 선언하기 전에 인스턴스를 만들수는 없다.

### 9.3.1 정적 메서드

- 정적 메서드는 프로토타입 객체의 프로퍼티가 아니라 생성자함수의 프로퍼티로 정의된다.
    
    ```tsx
    static parse(s) {
    	let matches = s.match(/"\((\d+)\.\.\.(\d+)\)$/);
    }
    let r = Range.parse('(1...10)');
    ```
    
- 정적 메서드는 클래스/생성자의 이름을 써서 호출하기 때문에 클래스 메서드라고 부른다.

---

## 9.4 기존 클래스에 메서드 추가

- 자바스크립트의 프로토타입객체에서 메서드를 추가하는 것 만으로도 자바스크립트 클래스를 확장할 수 있다.
    - 그러나 내장타입의 프로토타입에 메서드를 추가하는 것은 나중에 자바스크립트 새 버전에서 같은 이름의 메서드가 정의 될 수 있으므로 일반적으로 좋은 방법은 아니다.

---

## 9.5 서브 클래스

- 객체 지향 프로그래밍에서 클래스 B 가 클래스 A를 확장(extend) 할 때 A는 슈퍼클래스, B는 서브 클래스라고 한다.
    - 클래스 B는 자신만의 메서드를 정의할 수 있고, 클래스 A에 있는 같은 이름의 메서드를 덮어 쓸 수 있다.
        - 그런데 이떄, 덮어쓴 B에 존재하는 메서드가 A에 존재하는 덮어쓰인 메서드를 호출해야하는 경우가 있다.

### 9.5.1 서브 클래스와 프로토타입

- ES5 이전의 자바스크립트에서는 클래스에서 슈퍼클래스의 메서드와 생성자를 호출할 수 있도록 허용하는 방법을 단순하게 처리할 방법이 없었다.
    - ES6부터 class 문법의 super키워드를 도입하여 이 문제를 해결할 수 있다.

### 9.5.2 extends와 super를 사용하는 서브클래스

- 생성자에서 super()를 사용할때, 중요한 규칙
    - extends 키워드로 클래스를 정의하면 클래스 생성자는 슈퍼클래스 생성자를 호 출할 때 반드시 super()를사용해야합니다.
    - 서브클래스에 생성자를 정의하지 않으면 자동으로 생성됩니다. 이렇게 묵시적 으로 정의된 생성지는 전달된 값을 그대로 super()에 전달합니다.
    - super()를 써서 슈퍼클래스 생성자를 호출하기 전에는 생성자 안에서 this 키워 드를 사용하지 말아야 합니다. 이 규칙을 따르면 `서브클래스보다 슈퍼클래스를 먼저 초기화해야 한다는 규칙`도 지킬 수 있습니다.
    - new 키워드 없이 호출한 함수에서는 표현식 new.target의 값이 undefined입니 다. 반면 생성자 함수에서 new.target은 호출된 생성A}를 참조합니다. 서브클래 스 생성자를 호출하고 super()로슈퍼클래스 생성자를 호출하면, 슈퍼클래스 생 성자는 new.target을 통해 서브클래스 생성자를 참조할 수 있습니다. 슈퍼클래 스를 잘 설계했다면 서브클래스가 만들어졌는지 확인할 필요는 없지만, 예를 들
    어 메시지 로그를 만든다면 new.target.name을 사용할 수 있습니다.

### 9.5.3 위임과 상속

- 다른클래스의 동작을 공유하는 클래스를 원한다면 extends키워드를 통해 서브클래스를 만들어 동작을 상속할 수도 있지만, 클래스에서 다른클래스의 인스턴스를 만들고 그 인스턴스에 우리가 원한을 동작을 위임하는것이 더 쉽고 유연할때도 있다.
    - 동작을 위임하는 방식을 `합성` 이라 부르며, 객체 지향 프로그래밍에서는 `상속보다 합성을 우선시하라` 라는 격언이 자주 인용된다 한다.
    
    > 예시로 해당 클래스(Map)를 상속하는 것이 아닌,클래스의 constructor에서 Map객체를 초기화하고, 생성하려는 메서드에 해당 Map객체의 메서드를 이용하여 구현하는데 이를 Map객체에게 동작을 위임했다고 한다.
    > 

### 9.5.4 클래스 계층 구조와 추상 클래스

- 추상 클래스에서 말하는 추상 이라는 표현은 `구현되지 않은 메서드, 완전히 구현되지 않은 클래스` 를 가리키는 표현이다.
    - 추상 슈퍼클래스를 정의하여 서브클래스 가 상속한다면 슈퍼 클래스가 정의한 추상메서드를 구현 및 강제하여, 자신만의 고유한 동작을 정의할 수 있다.