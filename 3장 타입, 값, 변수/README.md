# 3장 타입, 값, 변수

## 3.1 개요와 정의

- 자바스크립트 타입은 기본타입과 객체타입을 나뉜다.
    - 기본타입
        - 숫자(number), 문자열(string), 불(boolean), null, undefined, Symbol
    - 객체 타입
        - 기본타입을 제외한 나머지

- `객체` 는 객체 타입의 멤버이며 프로퍼티의 집합이다.
    - 일반적인 객체는 이름 붙은 값의 순서 없는집합
        - 말이 어렵지만 그냥 형태를 보면 알 수 있다.
        
        ```tsx
        
        {
          a : string
        	b : number
        }
        ```
        
    - 특별한 객체인 배열은 값의 순서있는 집합이며, 각 값은 숫자로 표현된다.

- 자바스크립트의 객체 타입은 가변이며, 기본타입은 불변이다.
    
    > 메모리 상 참조 부분을 이야기 하는것 같음
    > 

---

## 3.2 숫자 (Number)

- 자바스크립트는 IEEE 754 표준에서 정의하는 64비트 부동 소수점 형식올 사용 해 숫자를 표현한다.
    - 이는 자바와 C++를 포함한 대부분의 최신 프로그래밍언어에서 doble 타입이라 부른다.
    - 9,007, 199,254, 740,992(-2^53) 이상, 9,007,199,254, 740,992(2^53) 이하 범위의 정수를 정확히 표현할 수 있다.
        - 그래서 이보다 큰 정수값을 사용하면 정확도가 떨어질 수 있다.

### 3.2.1 정수 리터럴

- 자바스크립트는 10진 정수 리터럴 뿐만 아니라 16진수(0x) 값도 인식한다
    
    ```tsx
    0xff // => 255: (15*16 + 15) 
    0xBADCAFE / / => 195939070
    ```
    
    - ES6 이후부터는 2진수 (0b) , 8진수(0o) 도 인식한다.
    
    ```tsx
    0b10101 //=>21: (1*16+0*8+1*4+0*2+l*l)
    0o377 // => 255: (3*64 + 7*8 + 7*1)
    ```
    

### 3.2.3 자바스크립트의 산술 연산

- 산술 연산자로 + , - , * ,/ , % , **(지수) 가 있다
- Math 객체의 프로퍼티로 정의된 함수와 상수를 통해 더 복잡한 수학 계산식도 지원한다.

- 자바스크립트는 연산 과정에 0으로 나누거나 오버/언더플로가 발생해도 에러를 일으키지 않는다., 대신 다른 값을 반환한다.
    
    ```tsx
    Infinity // 표현하기엔 너무 큰 앙수
    Number.POSITIVE INFINITY 
    1/0 // => Infinity
    Number,MAX VALUE * 2 //=> Infinity; 오버폴로
    
    //이외 ...
    ```
    

### 3.2.4 이진 부동 소수점 숫자와 반올림 오류

- 자바스크립트를 비롯해 최신 프로그래밍 언어에서 사용하는 IEEE 754 부동 소수점 표현은 이진 표현이다.
    - 그러나 , 0.1 과같은 단순한 숫자를 정확하게 표현을 하지는 못한다.
    
    ```tsx
    let x = .3 - .2; // 0.3 빼기 0.2
    lety=.2 - .1; // 0.2 빼기 0.1
    x === y //=> false: 두 값은 같지 않습니다!
    x === .1 // => false: 0.3 - 0.2는 0.1과 같지 않습니다. 
    y === .1 // => true: 0.2- 0.1은 0.1입니다.
    ```
    

### 3.2.5 BigInt

- BigInt는 ES2020에서 정의한 자바스크립트의 최신 기능중 하나이다.
    - 다른 프로그래밍 언어나 API와의 호환에 필요한 64비트 정수를 표현하기 위해 추가됐습니다.
    - 표현 방법 ( 뒤에 n을 붙인다)
        
        ```tsx
        1234n
        ```
        
- BigInt는 표준연산자를 다른 일반적인 숫자 피연산자와 함께 쓸 수 없다.

![Screen Shot 2023-03-01 at 6.13.07 PM.png](3%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8,%20%E1%84%80%E1%85%A1%E1%86%B9,%20%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20cd22aea2b2b9458e88e16eb43f55daba/Screen_Shot_2023-03-01_at_6.13.07_PM.png)

- 대신 비교연산자는 피연산자를 섞어도 문제가 없다.
    
    ```tsx
    1 < 2n // => true
    2 > ln // => true
    0 == 0n  // => true
    0 === 0n //=> false: ===는 타입까지 갈은지 체크합니다,
    ```
    

---

## 3.3 텍스트

- 문자열은 16비트 값 이 순서에 따라 이어진 형태이며, 기본 값이므로 불변이다.
    - 즉 문자하나를 표현하는데 16비트씩 쓴다.
    
- 자바스크립트에 문자 하나를 나타내는 타입이 따로 있지는 않다.
    - 16비트 값 하나를 표현하려면 그냥 길이가 1인 문자열을 쓰면 된다.
    

### 3.3.1 문자열 리터럴

- 자바스크립트 프로그램에 문자열을 사용할 때는 그 문자열을 앞뒤가 맞는 작은따 옴표(‘), 큰따옴표(“), 백틱(、) 쌍으로 묶으면 된다.

### 3.3.2 문자열 리터럴 안의 이스케이프 시퀀스

- 자바스크립트 문자열에서 역슬래시(\)는 특별한 의미를 갖는다
    - 역슬래시를 통해 문자열에 표시할 수 없는 문자를 표현한다.
    - 이스케이프 시퀀스라는 말은 역슬래시를 써서 작은 따옴표로 감싸인 문자의 일반적인 해석 방법을 벗어난다(이스케이프한다)는 의미이다.
    

### 3.3.3 문자열 다루기

- 문자열을 비교할 때는 일치 연산자(===) 와 불일치 연산자 !==  가 표준이다.
    - 두 문자열이 정확히 같은 16비트 값의 연속으로 이루어졌을 때에만 일치함
    - 또한 <, <=, >, >= 연산자로 비교할 수도 있다.

- 문자열의 길이는 length 프로퍼티로 알 수 있다.

- **자바스크립트의 문자열은 불변이라는 사실을 잊지 말자!**
    - String.replace()나 String.toUpperCase() 같은 메서드는 기존 문자열을 수정하는 것이 아니라 새 문자열을 반환한다.

- 문자열을 읽기 전용 배열로 취급해서 문자열의 특정 위치에 접근할 수도 있다.
    
    ```tsx
    let s =”hello, world”;
    s[0] // => ”h" 
    s[s.length-1] // => ”d”
    ```
    

### 3.3.4 템플릿 리터럴

- ES6 부터 백틱(`)으로 감싼 문자열을 사용할 수 있고, 이를 템플릿 리터럴이라 한다.
    - 템플릿 리터럴은 임의의 자바스크립트 표현식을 넣을 수 있다.
        - 프로세스
            - 템플릿 리터럴 안에 포함된 표현식을 평가해서 그 표현식의 값을 문자열로 변환한 다음, 변환된문자열을백틱 안에들어 있는 리터럴 문자와 결합한 값으로 결정
            

**태그된 템플릿 리터럴/**

- 템플릿 리터럴의 강력한 기능중 하나로, 여는 백틱(`) 앞에 함수 이름(태그)이 있으면, 그 함수에게 템플릿 리터럴이 전달 되고, 함수의 반환값이 태그된 템플릿 리터럴의 값이 된다.
    
    ```tsx
    `\n`.length // => 1 이 문자열에는 뉴라인 문자 하나만 있다.
    String.raw`\n`.length //=>2:역슬래시문자와n
    ```
    

### 3.3.5 패턴 매칭

자바스크립트에는 문자열 내부의 패턴을 정의하고 매칭하는 정규 표현식이 있다

- 정규 표현식 리터럴은 슬래시 한 쌍 사이에 택스트를 쓰는 형태이다.
    - 두번째 슬래시 뒤에도 글자 하나 이상 쓸 수 있으며 이 글자는 패턴의 의미를 수정한다.
    
    ```tsx
    /^HTML/; //문자열의 시작 부분에 있는 HTML에 일치합니다.
    /[1-9][0-9]*/; //0이 아닌 숫자가 하나 있어야 하고 그 뒤의 숫자는 제한이 없습니다.
    /\bjavascript\b/i; // javascript가 한 단어로 들어가야 하고 대소문자를 구분하지 않습니다.
    ```
    

---

## 3.4 불 값

- 불 값은 참 또는 거짓을 표현하고 이 타입에는 단 두가지 값만 존재한다.
    - true
    - false
    
- 자바스크립트 값을 모두 불 값으로 변환될 수 있다.
    - 아래의 값들은 모두 false로 변환될 수 있다. (falsy)
    
    ```tsx
    undefined 
    null
    0
    -0
    NaN
    ”” //빈문자열
    ```
    
    - 이외 다른값은 모두 true로 변환 될 수 있다 (truthy)
    

**불 연산자**

- && 연산자 (AND)
    - 둘 다 true일때만 true 반환 , 이외에 모두 false 반환
- || 연산자 (OR)
    - 둘중 하나만 true 이면 true 반환 , 이외 false 반환
    
- ! 연산자 (NOT)
    - false면 true, true 면 false 반환

---

## 3.5 null 과 undefined

- null 은 값이 없음을 나타낼때 사용하는 특별한 값이다.
    - `typeof null` 은 문자열 ‘object’를 반환하는데, 이는 null은 **‘객체가 없다’ 는 것을 나타내는 특별한 객체 값을** 의미한다고 볼 수 있다.
        - 그러나 null은 객체 뿐만 아니라, 숫자나 문자열에도 ‘값이 없다’ 라는 의미로 사용될 수도 있다.

- 또 다른 값이 없음을 나타내는 값으로 undefined가 있다.
    - null과는 또 다른의미이다.
    - 초기화 하지 않은 변수의 값이나 존재하지 않는 객체 프로퍼티 또는 배열에 접근했을때 반환되는 값이다.
    - 명시적으로 반환하지 않는 함수의 반환값 ( void )
    - 전달되지 않은 인자의 값
    - `typeof undefined` 는 문자열 ‘undefined’를 반환한다.
        - undefined 역시 특별한 타입이고 멤버는 그 하나뿐이라는 뜻
        

<aside>
💡 일반적으로 
undefined → 시스템레벨, 예측되지 않았거나 에러 비슷한 상황에서 값이 없는것이라 간주하고,
null → 프로그램 레벨, 정상적이거나 예측된 상황에서 값이 없는것이라 간주한다 (아닌사람도 있음)

</aside>

> 나도 혼용을 피하기 위해 프로그래밍시 주로 Null을 이용한다.
> 

---

## 3.6 심벌

> 심벌을 이해하기 위해서는 자바스크립트의 **객체 타입이 프로퍼티의 순서 없는 집합이며 각 프로퍼티에 이름과 값이 있다는 것을 이해해야 합니다**
> 

- 심벌은  ES6에서 추가된, 문자열이 아닌 프로퍼티 이름이다.
    - 프로퍼티 이름은 일반적으로 문자열이지만, ES6 이후에는 심벌 역시 문자열과 같은 의미로 사용할 수 있다.
        
        ```tsx
        const strname = 'string name'; // 프로퍼티 이름에 문자열을 썼습니다.
        const symname = Symbol('Propname'); // 프로퍼티 이름에 심벌을 썼습니다.
        typeof strname; // => "string": strname은 문자열입니다.
        typeof symname; // => "symbol": symname은 심벌입니다.
        const o = {}; // 새 객체를 생성합니다.
        o[strname] = 1; // 문자열 이름으로 프로퍼티를 정의합니다.
        o[symname] = 2; // 심벌 이를으로 프로퍼티를 정의합니다.
        o[strname]; // => 1: 이름이 문자열인 프로퍼티에 접근합니다,
        o[symname]; //=> 2: 이름이 심벌인 프로퍼티에 접근합니다.
        ```
        
- 심벌 타입에는 리터럴 문법이 없다.
    - 따라서 심벌 값을 가져오려면 Symbol() 함수를 호출 해야 한다.
    
    ```tsx
    cosnt symTest = Symbol('test')
    ```
    
    - **Symbol 함수는 절대 같은 값을 반환하지 않는다.**
        - == 같은 인자로 호출해도 절대 같은 값을 반환하지 않는다
        
        ```tsx
        Symbol('a') === Symbol('a') // false
        ```
        
        - 따라서 Symbol()을 통해 값을 얻었다면, 객체의 기존 프로퍼티를 같은 이름으로 덮어 쓸 염려 없이 그 값을 프로퍼티 이름으로 추가할 수 있다.
        - 마찬가지로 심벌인 프로퍼티 이름을 사용하고, 그 심벌을 공유하지 않는다면 다른 모듈에서 해당 심볼 프로퍼티를 덮어 쓸일이 없다는 뜻이다.

- 심벌은 사실 자바스크립트 언어를 확장하는 메커니즘이다.
    
    ```
    ES6에서 for/of 루프(5.4.4절)와 이터러블 객체(12장)를 도입했을때 
    클래스가 자기 자신을 이터러블로 만들 수 있는 표준 메서드를 정의해야 했습니다. 
    하지만 특정 문자열 이름을 이 이터레이터 메서드로 표준화하면 기존코드가 깨지는 것을 피할수 없었기에 
    심벌 이름을 도입한 것입니다.
    ```
    

- Symbol() 함수는 선택사항인 인자로 문자열을 받고 고유한 심벌 값을 반환하는데 이 인자는 심벌을 생성 하는데 아무런 영향이 없고 주로 디버깅 용으로 사용된다.
    
    ```tsx
    let s = Symbol(”sym_x”);
    s.toSt「ing() // => ”Symbol(sym_x)”
    ```
    

<aside>
💡 심벌을 내 코드에 만 쓸 수 있도록 비공개로 두어 다른 코드의 프로퍼티와 충돌하지 않게 하고 싶을 때가 있기도 하지만, **반대로, 다른 코드에서도 쓸 수 있도록 심벌을 정의하고 공유하고 싶을 수도 있다.**

</aside>

- 이는 앞에서 언급한 Symbol.iterator 메커니즘 같은 일종의 확장을 만들어 다른 코드에서도 사용할 수 있도록하는 것과 같다.
    - 자바스크립트는 이를 대응할 수 있도록 전역 심벌 레지스트리를 정의했다.
        - Symbol.for() 함수는 문자열 인자를 받아 그 문자열 인자와 연관된 심볼을 반환한다
            
            > key : value 느낌
            > 
        - 그러므로 Symbol.for() 함수는 Symbol() 함수와 완전히 다른것이다.

**[심볼에 관해서](https://poiemaweb.com/es6-symbol)** 

[Symbol과 Iterator](https://poiemaweb.com/es6-iteration-for-of)

---

## 3.7 전역 객체

- 이 객체의 프로퍼티는 전역으로 정의된 식별자이며 모든 자바스크립트 프로그램에서 사용할 수 있다
- 자바스크립트 인터프리터를 시작할때 혹은 웹 브라우저가 새 페이지를 로드할 때마다 새로운 전역 객체를 생성한다
    - 전역 상수 - undefined, Infinity, NaN
    - 전역 함수 - isNaN(), parseInt
    - 생성자 함수 - Date(), RegExp(), Object()
    - 전역 객체 - Math, JSON
- global - 노드에서의 전역 객체의 프로퍼티로 값은 전역 객체 그 자체
- Window- 웹 브라우저에서의 모든 자바스크립트 코드의 전역 객체이다
    - 이 객체에는 자신을 참조하는 window 프로퍼티가 있고 이 프로퍼티를 통해 전역 객체를 참조할 수 있다
    - 이 객체에는 웹 브라우저와 클라이언트 사이드 자바스크립트에 밀접한 전역 변수도 몇가지 정의되어 있다
- globalThis - 어떤 환경에서든 전역 객체를 참조하는 표준(브라우저, 노드)

---

## 3.8 불변인 기본값과 가변인 객체 참조

- 기본 값
    - 불변의 값
    - 문자열의 경우 몇몇 메서드가 수정된 문자열을 반환하는 것처럼 보이지만 사실 새 문자열 값을 반환하는 것
    - 값으로 비교함

```jsx
let s = "hello"
s.toUpperCase() // HELLO
s // hello
```

- 객체
    - 가변의 값
    - 객체는 참조로 비교함. 두 객체의 값이 같다는 말은 오직 두 값이 같은 객체를 참조할 때에만 성립.

```jsx
let o = {x:1}, p = {x:1}
o === p // false
let a = [1], b = [1]
a === b // false

a = []
b = a // 같은 객체를 참조함
b[0] = 2
a[0] // 2
a === b //true
```

---

## 3.9 타입 변환

- 자바스크립트는 값의 타입을 강제하지 않고 필요에 맞게 형변환 해줌

```jsx
10 + " objects" // "10 objects"
"7" * "4" // 28
let n = 1 - "x" // NaN <- 형변환 실패
n + " objects" // "NaN objects" NaN 은 문자열로 변환 o
```

- false 값으로 변환되는 값들
    - undefined, null, “”, 0, -0, NaN
- true 값으로 변환되는 값들
    - {}, [], 1, Infinity, -Infinity, function(){}

### 3.9.2 명시적 변환

- 단순한 형변환

```jsx
Number("3") // 3
String(false) // "false" false.toString() 도 같음
Boolean([]) // true
```

- + 연산자는 피연산자 중 하나가 문자열이면 다른 피연산자도 문자열로 변환한다
- 단항 + 연산자는 피연산자를 숫자로 변환한다
- 단항 ! 연산자는 피연산자를 불로 변환한 수 다시 부정한다

- Number 클래스의 형변환 메서드
    - toString() -  선택적으로 기수를 인자로 받는다.(인자 생략시 10진수로 변환)
    - toFixed() - 숫자를 문자열로 변환할 때 소수점 아래 몇자리를 표시할지 인자로 넘겨 지정할 수 있다
    - toExponential() - 지수 표기법을 사용해서 숫자를 문자열로 변환한다
    - toPrecision() - 지정하는 유효 숫자에 따라 숫자를 문자열로 변환한다

```jsx
let n = 17
let binary = "0b" + n.toString(2) // "0b10001"
let octal = "0o" + n.toString(B) // "0o21"
let hex = "0x" + n.toString(l6) // "0x11"
```

### 3.9.3 객체를 기본 값으로 변환

자바스크립트 명세에는 객체를 기본 값으로 변환하는 세 가지 기본적인 알고리즘이 정의되어 있다

- 문자열 선호
    - Date 클래스는 선호 없음 알고리즘에 문자열 선호를 적용.
    - toString() →  valueOf()
- 숫자 선호
    - valueOf() → toString()
- 선호 없음
    - 클래스에서 변환 방법을 정의할 수 있음. 클래스에 따라 다르게 동작
    - Date 를 제외한 모든 타입이 이 알고리즘에 숫자 선호를 적용.
    

---

## 3.10 변수 선언과 할당

- 변수 선언 - 값을 표현할 식별자 선언, 할당 - 값을 참조
- 상수 - 값에 이름을 영구히 할당할 때

※ const 를 써야 할 때

- 바뀌어서는 안되는 값에만
- 바뀌지 않을것으로 생각되는 모든 값에 → 후자까지 const 를 써야 한다고 생각

**변수와 상수 스코프**

- let, const 로 선언한 변수와 상수는 블록 스코프를 가진다
- var 로 선언한 변수는 함수 바디를 스코프로 가진다
    - 함수 바디 바깥에서 var 를 사용하면 전역 변수로 선언된다
    - var 로 선언된 전역 변수는 전역 객체의 프로퍼티로 존재한다
    - var 로 선언된 전역 변수는 delete 연산자로 삭제할 수 없다
- 선언이 어떤 코드 블록에도 속하지 않고 최상위 레벨이 있을 경우 전역 스코프를 가진다

### 3.10.3 분해 할당(destructuring assignment)

- 분해 할당이 일어나면 오른 값에서 하나 이상의 값을 추춘해서 왼쪽에 있는 변수에 할당한다

```jsx
let [x,y] = [1,2]
[x, y] = [x+1, y+1]
[x,y] = [y,x]
[x,y] // [3,2]
```

- 분해 할당에서 왼쪽에 있는 변수 숫자와 오른쪽에 있는 값 숫자가 꼭 일치할 필요는 없다. 남는 쪽이 undefined 가 할당 된다.
- 점 세개 (…) 를 써서 배열을 분해하고 남은 값을 변수 하나에 모을 수 있다. 배열 뿐만 아니라 이터러블 객체면 무엇이든 분해해서 쓸 수 있다

```jsx
let [x,y] = [1] // y = undefined
[x,y] = [1,2,3] // x = 1, y = 2
[,x,,y] = [1,2,3,4] // x = 1, y = 4
let [x,...y] = [1,2,3,4] // y = [2,3,4]

let [first, ...rest] = "Hello" // first = "H", rest = ["e","l","l","o"]
```

- 분해 할당은 중첩된 배열에서도 사용할 수 있다
- 객체도 분해 할당 할수 있다

```jsx
let [a,[b,c]] = [1,[2, 2.5]] // a = 1, b = 2, c = 2.5
let {r,g,a} = = {r: 0.0, g: 0.0, b: 0.0, a: 1.0} // r = 0.0, g = 0.0, a = 1.0
const {sin, cos, tan} = Math // Math의 프로퍼티 이름이 아닌 변수가 있다면 undefined 가 할당된다
```

- 분해 할당은 중첩된 객체, 객체의 배열, 배열의 객체 등에도 사용할 수 있다

```jsx
let points = [{x:1, y:2}, {x:3, y:4}]
let [{x:x1, y:y2}, {x:x2, y:y2}] = points
(xl === 1 && yl === 2 && x2 === 3 && y2 === 4) //true

let points2 = { pl: [1,2], p2: [3,4] } 
let { pl: [x1, y1], p2: [x2, y2] } = points2 
(x1 === 1 && y1 === 2 && x2 === 3 && y2 === 4) // true
```