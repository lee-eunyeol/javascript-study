# 배열

- 배열은 **값의 순서있는 집합**이다.
- 자바스크립트 배열에는 타입이 없다.
    - 따라서 배열 요소는 어떤 타입이든 상관없고, 배열 여러타입이 섞여있어도 괜찮다.
- 자바스크립트 배열은 `0으로 시작` 하는 32비트 인덱스를 사용한다.
    - 첫번째 요소의 인덱스는 0이고, 인덱스는 최대 2^32-2 (약 43억)까지 커질수 있다
- 자바스크립트는 성긴(sparse) 배열을 허용한다
    - 즉 요소의 인덱스가 꼭 이어질 필요는 없고 그 사이에 갭이 있어도 된다.
- 자바스크립트 배열은 length 프로퍼티가 있다.
    - 성기지않은 배열에서 이 length 프로퍼티는 배열에 포함된 요소 숫자이다.
        - 성긴 배열의 length는 배열 내 가장 큰 인덱스보다 크다.
- 자바스크립트 배열은 객체의 특별한 형태이다.
    - 배열 인덱스 프로퍼티 이름이 정수인 것과 별로 다르지 않다.
    - 자바스크립트 실행 환경은 일반적인 객체 프로퍼티보다 상당히 빠르게 접근할 수 있다.
- 배열은 Array.prototype 에서 프로퍼티 상속 한다.

---

## 7.1 배열 생성

### 7.1.1 배열 리터럴

- 배열을 만드는 가장 단순한 방법으로 배열 요소를 대괄호 안에서 콤마로 구분한 리스트 형태이다.
    
    ```tsx
    let empty = []; // 요소가 없는 배열
    let primes = [2, 3, 5, 7, 11]; // 숫자 요소가 다섯 개 있는 배열
    let misc = [ 1.1, true, "a", ]; // 타입이 다른 요소가 세 개 있고 콤마로 끝난 배열
    ```
    
- 배열 리터럴에 꼭 상수가 아니라 임의의 표현식을 써도 된다.
    
    ```tsx
    let base = 1024;
    let table = [base, base+1, base+2, base+3];
    ```
    
- 배열 안에 객체 리터럴이나 다른 배열 리터럴도 가능하다
    
    ```tsx
    let b = [[1, {x: 1, y: 2}], [2, {x: 3, y: 4}]];
    ```
    
- 배열 리터럴에 콤마를 연속해서 썼는데, 그 사이에 값이 없으면 성긴 배열이 만들어진다.
    - 실제로 배열 요소가 존재하지는 않지만 검색하면 undefined가 반환된다.
    
    ```tsx
    let count= (1,,3]; // 인텍스 @과 2에는 요소가 있지만 인돼스 1에는 요소가 없습니다. 
    let undefs = [,,]; // 요소가 없지만 길이가 2인 배열
    ```
    
    - 배열 리터럴 문법은 마지막에 콤마를 허용하므로 [,,]의 길이는 3이 아니라 2이다.
    

### 7.1.2 분해 연산자

- ES6 이후에는 분해 연산자 `...` 을 써서 배열 리터럴 안에 다른 배열 요소를 넣을 수 있다.
    
    ```tsx
    let a = [1, 2, 3];
    let b = [0, ...a, 4]; //b == [0, 1, 2, 3, 4]
    ```
    
    - 분해 연산자는 배열을 얕게(shallow) 복사할 때도 유용하다.
    
    ```tsx
    let Original = [1,2,3];
    let copy = [...original];
    copy[0] = 0; // 사본을 수정해도 원본에는 영향이 없습니다. original[0] // => 1
    ```
    
    - 분해 연산자는 모든 이터러블 객체에 동작한다
        - 이터러블 객체 for/of 루프의 대상이 될 수 있는 객체이다.

### 7.1.3 Array() 생성자

- Array() 생성자를 이용하여 배열을 만들수도 있는데 세가지 방법으로 호출할 수 있다.
    - 인자 없이 호출
        - 빈 배열을 생성하며, 배열 리터럴 [] 과 동등하다
            
            ```tsx
            let a = new Array();
            ```
            
    - 배열 길이를 나타내는 숫자 인자 하나로 호출
        - 이 방법은 지정된 길이를 가진 배열을 생성한다.
            - 아직 배열에 값을 저장하지 않았고, 배열 인덱스 0,1 , … 등도 아직 정의하지 않았다.
        
        ```tsx
        let a = new Array(10);
        ```
        
    - 배열 요소를 두개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출
        - 생성자의 인자가 배열의 요소가 됨
        
        ```tsx
        let a = new Array(5, 4, 3, 2, 1, ”testing, testing");
        ```
        

### 7.1.4 Array.of()

- Array() 생성자만으로는 숫자 요소가 하나만 있는 배열은 생성할 수 없다.
    - ES6의 Array.of() 함수는 이 문제를 해결한다.
        - 이 함수는 인자의 개수를 따지지 않고 각 인자를 새 배열의 요소로 사용한다.
        
        ```tsx
        Array.of() // => []; 인자가 없으므로 빈 배열
        Array.of(10) // => [10]; 숫자 인자 하나만 있어도 됩니다.
        Array.of(1,2,3)  // => [1, 2, 3]
        ```
        

### 7.1.5 Array.from()

- Array.from 역시 ES6에서 도입한 팩토리 메서드이다.
    - [팩토리 메서드란?](https://velog.io/@ljo_0920/%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C)
    - 이 메서드는 첫 번째 인자로 이터러블 객체나 배열 비슷한 객ㄱ체를 받으며, 해당 객체의 요소로 새 배열을 만들어 반환한다.
    - Array.from(iterable)은 분해 연산자를 사용한 [... iterable]과 동등하다.
        
        ```tsx
        let copy = Array.from(original);
        ```
        
- Array.from()이 중요한 이유는 **배열 비슷한 객체를 진정한 배열로 바꾸기 때문**이다.
    - 배열 비슷한 객체 → ArrayLike
        - length 프로퍼티가 있고, 이름이 정수인 프로퍼티 값이 저장된 객체
    
    ```tsx
    let trueArray = Array.from(arrayLike);
    ```
    
- Array.from()은 선택사항으로 두번째 인자를 받는다.
    - 두번째 인자로 함수를 전달하면, 새 배열을 생성할때 소스객체의 각요소를 이 함수에 전달하고 반환값을 배열에 저장한다.

---

## 7.2 배열 요소 읽기와 쓰기

- 배열 요소에 접근할때는 [] 연산자를 사용한다.
    - 대괄호 왼쪽에는 배열 참조가 있어야 한다.
        - 대괄호 안에는 양의 정수로 평가되는 표현식이 있어야한다
        
- 2^32-1 보다 작은 양의 정수인 인덱스에 값을 할당하면, 그 배열의 length 프로퍼티가 자동으로 바뀐다.
    
    ```tsx
    a = [1] // length : 1
    a[1] = 2 
    a.length // legnth : 2
    ```
    
- 배열은 특별하긴 하지만 결국엔 객체이다
    - 배열 요소에 접근할대 사용하는 대괄호는 객체 프로퍼티에 접근할 때 사용하는 대괄호와 마찬가지로 동작한다.
    - 자바스크립트는 숫자인 배열 인덱스를 문자열로 변환한다.
        - 즉 인덱스 1은 문자열 “1” 이되며, 이 문자열을 프로퍼티 이름으로 사용한다.
            - 따라서 배열 인덱스와 객체 프로퍼티 이름을 명확히 구별하는 것이 좋다.
            - 프로퍼티 이름은 0 이상 2^32 -2 이하 범위에 속해야만 인덱스로 쓸 수 있다.
        - 배열 인덱스인 프로퍼티를 사용하면, 배열에서 length 프로퍼티를 업데이트 하는 특별한 동작을 한다.
        
- 배열 인덱스에는 음수도, 정수 아닌 숫자도 쓸 수 있긴 하다.
    - 이렇게 하면 숫자를 문자열로 변환하고 그 문자열을 프로퍼티 이름으로 사용한다.
        - 이런 프로퍼티는 이름이 양의 정수가 아니므로 일반적인 객체 프로퍼티로 취급한다.
        - 마찬가지로, 양의 정수로 평가되는 문자열을 인덱스로 사용하면 객체 프로퍼티가 아니라 배열 인덱스로 취급한다.
        
        ```tsx
        a[-1.23] = true; // -1.23 이라는 프로퍼티 생깁니다.
        a["1000"] = 0; // 배열의 1001번째 요소
        a[1.0000] = 1; // 배열인덱스 1. a[1] = 1; 과 같습니다.
        ```
        
- 배열 인덱스는 조금 특별한 타입의 객체 프로퍼티 이름일 뿐이므로 자바스크립트 배열에는 ‘경계 초과(out of bounds)’ 에러는 일어나지 않습니다.
    - 즉 객체에 존재하지 않는 프로퍼티를 검색해도 에러가 에러가 일어나지 않고 undefined를 반환한다.
    
    ```tsx
    let a = [true, false]; // 이 배열은 인돼스 8과 1에 요소가 있습니다.
    a[2] // => undefined; 이 인댁스에는 요소가 없습니다. 
    a[一1] // => undefined; 이련 이름의 프로퍼티는 없습니다
    ```
    

---

## 7.3 성긴 배열

- 성긴 배열은 인덱스가 연속적이지 않은 배열이다.
    - 일반적으로 배열의 length 프로퍼티는 배열에 포함된 요소의 개수이지만, 성긴 배열의 경우 legnth 프로퍼티의 값이 요소 개수보다 크다.
- 성긴 배열은 Array() 생성자를 사용하거나, 현재 배열 length 보다 큰 인덱스에 요소를 할당하면 만들어진다.
    
    ```tsx
    let a =new Array(5); // 요소가 없지만 a.length는 5입니다.
    a = [];// 요소가 없고 length가 0인 배열
    a[1000] = 0;// 요소는 하나를 추가하지만 길이는 1001로 만드는 할당
    
    ```
    
- [1,,3] 처럼 배열 리터럴에 콤마를 반복해도 성긴 배열이 만들어진다.
    - 생략된 요소는 존재하지 않는다.
    
    ```tsx
    let al = [,];// 이 배열은 요소가 없고 길이는 1입니다.
    let a2 =[undefined]; // 이 배열에는 undefined 요소가 하나 있습니다.
    0 in al // => false: al은 인댁스 @에 요소가 없습니다.
    0 in a2 // => true: a2는 인텍스 0에 undefined 값이 있습니다.
    ```
    
    - 성긴 배열을 이해하는 것은 자바스크립트 배열의 본질을 이해하기 위해 중요하다
        - 그러나, 현실적으로 대부분 자바스크립트 배열은 성기지 않은 배열이다.
            - 실제로 성긴 배열을 다뤄야 할 때가 있더라도, 아마 코드에서는 그 배열을 undefined 요소가 포함된 빽빽한 배열(요소가 꽉 찬)로 취급할 것이다.

---

## 7.4 배열 길이

- 모든 배열에는 length 프로퍼티가 있다
    - 이 프로퍼티는 일반적인 자바스크립트 객체와 배열을 구분하는 특징이다.
    
- 빽빽한 배열에서 length 프로퍼티는 배열에 포함된 요소 개수와 같다.
    - 그 값은 배열에서 가장 큰 인덱스에 1을 더한 값이다.
    
    ```tsx
    [].length // => 0: 배열에 요소가 없음
    ["a","b","c"].length // => 3: 가장 큰 인덱스는 2이고 길이는 3
    ```
    
- 성긴 배열의 length 프로퍼티는 포함된 요소 개수보다 크다
    - length가 가장 큰 인덱스보다 더 크다는 사실과 같다.
    - 달리 말하자면 배열에는 length 보다 크거나 같은 인덱스는 존재하지 않는다.
        - 이에 자바스크립트 배열에는 두가지 특별한 동작이 있다.
            - 배열의 현재 길이 이상인 i 인덱스에 값을 할당할때 length 프로퍼티를 i+1 갱신
            - 배열의 length 프로퍼티를 현재 값보다 작은 양의 정수 n으로 지정할때, 인덱스가 n 이상은 모든 배열 요소는 모두 삭제한다
            
            ```tsx
            a = [1,2,3,4,5]; // 요소가 다섯 개 있는 배열로 시작합니다.
            a.length=3; //a는이제 [1,2,3]입니다.
            a.length=0; //요소전체를삭제합니다. a는 []입니다.
            a.length= 5; // 길이는 5이지만 new Array(5)와 마찬가지로 요소는 없습니다.
            ```
            
        - length 프로퍼티를 현재 값보다 큰 값으로 설정 할수도 있지만 실제로 새 요소가 추가되는거은 아니며, 그만큼 성긴 영역이 생길 뿐이다.

---

## 7.5 배열 요소 추가와 삭제

- 이전에 본것 처럼 새 인덱스에 값을 할당하는 방법이다.
    
    ```tsx
    let a = []; // 빈 배열로 시작
    a[0] = "zero"; // 요소를 추가
    a[1] = "one";
    ```
    
- push() 메서드는 배열 마지막에 값을 추가한다.
    
    ```tsx
    let a = []; // 빈 배열로 시작.
    a.push("zero") // 마지막에 값을 추가한다. a = ["zero"]
    a.push("one", "two") // 값을 두개 더 추가
    ```
    
    - push()는 a[a.length]에 값을 할당하는 것과 같다.
        - pop() 메서드는 push()의 반대로 배열의 마지막 요소를 제거하고, 그 값을 반환하며, 배열의 길이를 1만큼 줄인다.
        - shift()는 반대로 배열의 첫번째 요소를 제거하고 반환하며, 길이를 1만큼 줄이고 나머지 요소를 모두 앞당긴다
- delete 연산자로 배열 요소를 삭제할 수 있다.
    
    ```tsx
    let a = [1,2,3];
    delete a[2]; // a는 이제 인텍스 2에 요소가 없습니다.
    2 in a // => false: 배열 인텍스 2는 정의되지 않았습니다.
    a.length // => 3: delete는 배열 길이에 영향을 주지 않습니다.
    ```
    
    - 배열 요소를 삭제하는 것은 그 요소에 undefined를 할당하는 것과 비슷하다.
        - 따라서 delete를 사용해도 배열의 length 프로퍼티는 변하지 않는다.
            - 성긴 배열이 된다는 뜻이다.
            

---

## 7.6 배열 순회

- ES6 이후 배열 요소나 이터러블 객체를 순회하는 가장 쉬운 방법은 5.4.4 절에서 자세히 설명한 for/of 루프이다

- for/of 루프가 사용하는 내장 이터레이터는 오름차순으로 요소를 반환한다
    - 성기 배열도 마찬가지이며, 존재하지 않는 배열 요소에 대해서는 undefined를 반환한다.
    
- 배열에 for/of 루프를 적용할 때 각 요소의 인덱스가 필요하다면 entries() 메서드와 분해할당을 이용하면 된다.
    
    ```tsx
    let everyother = ””;
    for(let [index , letter] of letters.entries()) {
    	if (index% 2 === 0) 
    	everyother += letter; 
    }
    everyother //=> "Hlowrd”
    ```
    
- forEach() 도 배열을 순회하는 좋은 방법이다.
    - 이 메서드는 배열 순회를 함수형으로 바꾼 배열 메서드이다.
    
    ```tsx
    let uppercase = 1111;
    letters.forEach(letter => {  // 화살표 함수 문법올 썼습니다.
    uppercase += letter.toUpperCase(); });
    uppercase // => ”HELLO WORLD”
    ```
    
    - forEach()는 for/of 루프와 달리 성긴 배열을 인식하고, 존재하지 않는 요소에 대해서는 함수를 호출하지 않는다.

---

## 7.7 다차원 배열

- 자바스크립트에서 다차원 배열을 직접 지원하지는 않다.
    - 그러나 배열을 만들어 대략적으로 흉내낼 수는 있다.
    
    ```tsx
    // 다차원 배멸을 생성합니다.
    let table = new Array(10); // 테이블 행은 10개입니다. 
    for(let i = 0; i < table.length; i++) {
    		table[i] = new Array(10); // 각 행에는 열이 10개씩 있습니다.
    }
    // 배열 초기화
    for(let row = 0; row < table.length; row++) {
    		for(let col= 0; col< table[row].length; col++) { 
    				table[row][col] = row * col;
    }
    // 다차원 배열을 사용해 5*7올 계산합니다. 
    table[5][7] //=> 35
    ```
    

---

## 7.8 배열 메서드

- 배열 메서드 중 일부는 원래 배열을 수정하고, 나머지는 배열을 수정하지 않는다
    - 일부 메서드는 원래 배열을 그대로 둔 채 새 배열을 반환한다
    - 나머지 메서드는 원래 배열을 수정하고 그 참조를 반환한다

### 7.8.1 배열 이터레이터 메서드

- 이터레이터 메서드는 모두 첫번째 인자로 함수를 받는다
- 이터레이터 메서드 대부분은 선택사항으로 두 번째 인자를 받는다. 두 번째 인자가 지정되었다면 그것이 함수의 this가 된다

`forEach()`

- 배열 요소의 값, 배열 요소의 인덱스, 배열 자체를 인자로 전달해 이 함수를 호출한다
- 배열 요소의 값에만 관심이 있다면 인자 하나만 받는 함수를 작성하고 나머지 값은 무시해도 된다
- 모든 요소를 함수에 전달하기 전에 반복을 멈추는 방법은 없다

```jsx
let data = [1,2,3,4,5], sum = 0
data.forEach(v => sum += value)
// sum === 15

data.forEach((v,i,a) => {
	a[i] = v + 1
})
// data === [2,3,4,5,6]
```

`map()`

- 각 배열 요소를 함수에 전달해 호출하며, 그 함수가 반환한 값으로 이루어진 새 배열을 반환한다
    - 기존 배열은 수정하지 않는다는 뜻
    - 성긴 배열이라면 존재하지 않는 요소에 대해서는 함수를 호출하지 않지만, 반환된 배열 역시 같은 위치에 갭이 있으며 길이 또한 같다
- map() 에 전달하는 함수는 forEach() 에 전달하는 함수와 같은 방법으로 호출된다
- map() 메서드에 전달하는 함수는 값을 반환해야 한다

```jsx
let a = [1,2,3]
a.map(x => x*x) // [1,4,9]
```

`filter()`

- 기존 배열의 일부만 포함하는 부분 집합을 반환한다
- 전달하는 함수를 기준으로 하며 이 함수는 true 또는 false 를 반환한다
- 반환 값이 true 이거나 true 로 변환될 수 있는 값이면, 해당 요소는 반환되는 배열에 포함된다

```jsx
let a = [5,4,3,2,1]
a.filter(x => x < 3) // [2,1]
a.filter((v,i) => i % 2 === 0) // [5,3,1]
```

- 성긴 배열에서 존재하지 않는 값은 건너뛰며, 반환하는 배열은 항상 빽빽한 배열이다

```jsx
// 다음과 같이 성긴 배열에서 갭을 제거할 수 있다
let dense = sparse.filter(() => true)

// 다음과 같이 갭과 함께 undefined, null 요소도 제거할 수 있다
a = a.filter(v => v !== undefined && v !== null)
```

`find() 와 findIndex()`

- 판별 함수에서 true 같은 값을 반환하는 요소를 찾아 배열을 순회한다는 점에서 filter() 와 같다
- 하지만 이들 메서드는 기준을 만족하는 첫번째 요소를 찾는 즉시 순회를 멈춘다
- 만족하는 요소를 찾으면 find() 는 그 요소를, findIndex() 는 그 요소의 인덱스를 반환한다
- 만족하는 요소를 찾지 못하면 find() 는 undefined 를, findIndex() 는 -1을 반환한다

```jsx
let a = [1,2,3,4,5]
a.findIndex(v => v === 3) // 2
a.findIndex(v => v < 0) // -1
a.find(x => x % 5 === 0) // 5
a.find(x => x % 7 === 0) // undefined
```

`every() 와 some()`

- 배열 요소에 판별 함수를 적용하고 결과에 따라 true 또는 false 를 반환한다
- every() 메서드는 판별 함수가 배열의 모든 요소에 대해 true 를 반환할 때만 true 를 반환한다

```jsx
let a = [1,2,3,4,5]
a.every(v => v < 10) // true
a.every(v => v % 2 === 0) // false
```

- some() 메서드는 배열 요소 중 판별 함수가 true 를 반환하는 것이 하나라도 있으면 true 를 반환하며, 요소 전체가 false 를 반환할때만 false 를 반환한다

```jsx
let a = [1,2,3,4,5]
a.some(v => v % 2 === 0) // true
a.some(isNaN) // false
```

- every() 와 some() 은 자신이 어떤 값을 반환할지 확실해지는 순간 순회를 멈춘다
- 빈 배열에 호출했을 때 every() 는 true 를 반환하고 some() 은 false를 반환한다

`reduce() 와 reduceRight()`

- reduce() 와 reduceRight() 메서드는 제공하는 함수를 사용해 배열 요소를 값 하나로 만든다
- reduce() 는 인자 2개를 받는데 첫 번째는 축소 동작을 행하는 함수, 두 번째는 선택 사항이며 함수에 전달할 초깃값이다

```jsx
let a = [1,2,3,4,5]
a.reduce((x,y) => x+y, 0) // 15
a.reduce((x,y) => x*y, 1) // 120
a.reduce((x,y) => (x > y) ? x : y) // 5 가장 큰 값
```

- reduce() 에 사용하는 함수는  축소 작업의 누적된 결과 값, 인덱스, 배열을 인자로 계속해서 전달한다
- reduce() 에 초깃값을 넘기지 ㅇ낳으면 배열의 첫 번째 요소를 초기값으로 사용한다
- 빈 배열에 초깃값 없이 reduce() 를 호출하면 TypeError 가 일어난다
- 값이 하나만 있는 배열에서 초깃값을 생략하고 호출하거나, 빈 배열에 초깃값을 넘기면서 호출하는 등 reduce() 에 값을 하나만 넘기면 그 값을 그대로 반환하며 함수는 호출하지도 않는다
- reduceRight() 은 reduce() 와 마찬가지지만 진행 순서가 반대라는 **점이 다르다**

```jsx
let a = [2,3,4]
a.reduceRight((acc, val) => Math.pow(val, acc)) // 2.41785....
```

- reduce() 나 reduceRight() 는 축소 함수에서 this 로 사용될 인자는 받지 않는다
- reduceRight() 는 축소 동작의 결합성이 오른쪽에서 왼쪽일 경우 유용할 수 있다

### 7.8.2 flat() 과 flatMap() 을 사용한 배열 평탄화

- ES2019 에서 도입한 flat() 메서드는 기존 배열과 같은 요소로 이루어진 평탄한 새 배열을 반환한다

```jsx
[1,[2,3]].flat() // [1,2,3]
[1,[2,[3]]].flat() // [1,2,[3]]
```

- 인자 없이 flat() 을 호출하면 한 단계만 평탄화 된다
- 평탄화 레벨을 늘리려면 flat() 에 숫자를 전달해야 한다

```jsx
let a = [1,[2,[3,[4]]]]
a.flat(1) // [1,2,[3,[4]]]
a.flat(4) // [1,2,3,4]
```

- flatMap() 메서드는 map() 메서드와 똑같이 동작하지만, 반환하는 배열이 flat() 에 전달한 것처럼 자동으로 평탄화 된다는 점이 다르다
- a.flatMap(f) 는 a.map(f).flat() 과 동등하지만 더 효율적이다

```jsx
let phrases = ["hello world", "the definitive guide"]
let words = phrases.flatMap(v => v.split(""))
words // ["hello", "world", "the", "definitive", "guide"]
```

- flatMap() 은 사용하기 따라서 기존 배열의 요소 일부를 빈 배열로 바꿔, 평탄화를 거치면 결과 배열에는 아무것도 남지 않게 할 수도 있다

```jsx
[-2,-1,1,2].flatMap(x => x < 0 ? [] : Math.sqrt(x))
// [1, 2**0.5]
```

### 7.8.3 concat() 으로 배열 병합

- concat() 메서드는 기존 배열의 요소를 포함하고 그 뒤에 concat()의 인자를 포함하는 새 배열을 만들어 반환한다
- 인자에 배열이 들어있으면 배열이 아니라 그 요소를 추가한다
- 하지만 concat() 은 배열의 배열을 재귀적으로 평탄화하지는 않는다
- concat() 은 원래 배열의 사본을 만들어 반환해서 비용이 드는 작업이다
    - 경우에 따라서 push() 나 splice() 를 대신 쓸 수 없는지 생각해 봐야 함!

```jsx
let a = [1,2,3]
a.concat(4,5) // [1,2,3,4,5]
a.concat([4,5], [6,7]) // [1,2,3,4,5,6,7]
a.concat(4, [5,[6,7]]) // [1,2,3,4,5,[6,7]]
a // [1,2,3]
```

### 7.8.4 스택과 큐 메서드

- push() 와 pop() 메서드는 배열을 스택처럼 다루는 메서드이다
- push() 메서드는 배열의 끝에 하나 이상의 새 요소를 추가하고 새 길이를 반환한다
    - concat() 과 달리 push() 는 배열 인자를 평탄화 하지는 않는다
- pop() 메서드는 배열의 마지막 요소를 꺼내서 반환하며 배열 길이를 줄인다
- 두 메서드 모두 기존 배열을 수정한다

```jsx
let stack = []
stack.push(1,2) // [1,2]
stack.pop() // 2, stack === [1]
stack.push([4,5]) // [1,[4,5]]
stack.pop() // [4,5], stack === [1]
```

- push() 메서드는 전달한 배열을 평탄화하지는 않는다
    - 배열 요소를 다른 배열에 모두 넣고 싶다면 분해 연산자를 직접 사용해 평탄화할 수 있다
    
    ```jsx
    a.push(...values)
    ```
    
- unshift() 와 shift() 메서드는 push(), pop() 과 거의 비슷하지만 배열의 마지막이 아니라 앞부분에서 이루어진다
- unshift() 는 배열의 시작 부분에 요소를 추가하고, 새 길이를 반환한다
- shift() 는 배열의 첫번째 요소를 꺼내 반환하고, 기존 배열 요소를 앞으로 당긴다
- 명령할 때마다 기존 배열 요소를 앞뒤로 미는 작업이 수반되어야 하므로 push() 나 pop() 에 비해 비효율적이다

```jsx
let q = [1,2,3]
q.shift() // 1, q === [2,3]

q.unshift(1) // [1,2,3]
q.unshift(0, -1) // [0,-1,1,2,3]
```

### 7.8.5 하위 배열

`slice()`

- slice() 메서드는 지정된 배열의 하위 배열을 반환한다
- 두 개의 인자는 각각 반환될 슬라이스의 시작과 끝 위치를 나타낸다
- 반환된 배열에는 첫 번째 인자로 지정된 요소에서 시작해, 두 번째 인자로 지정된 요소 바로 앞까지가 포함된다
- 인자를 하나만 사용한다면 반환된 배열은 해당 위치부터 원래 배열의 마지막 요소까지 포함한다
- 인자에 음수를 사용한다면 그 값에 배열 길이를 더한 값을 적용한다.
    - 예를 들어 -1 은 배열의 마지막 요소이고, -2는 마지막에서 바로 앞 요소이다

```jsx
let a = [1,2,3,4,5]
a.slice(0,3) // [1,2,3]
a.slice(3) // [4,5]
a.slice(1,-1) // [2,3,4]
a.slice(-3,-2) // [3]
```

`splice()`

- splice() 는 배열에 요소를 삽입하거나 제거하는 범용 메서드이다
- splice() 는 원래 배열을 수정한다
- 배열에서 요소를 삭제하거나 삽입할 수 있고 두 동작을 동시에 할 수도 있다
- 삽입이나 제거가 이루어진 위치 다음에 오는 요소들을 앞뒤나 뒤로 밀어 배열을 빽빽하게 유지한다
- 첫번째 인자는 삽입이나 제거를 시작할 위치이다
- 두번째 인자는 제거할 요소의 개수이다
- 두번째 인자를 생략하면 시작 시점부터 배열 마지막까지의 요소를 모두 제거한다

```jsx
let a = [1,2,3,4,5,6,7,8]
a.splice(4) // [5,6,7,8], a === [1,2,3,4]
a.splice(1,2) // [2,3], a === [1,4]
a.splice(1,1) // [4], a === [1]
```

- splice() 의 첫 번째와 두 번째 인자는 제거할 배열 요소를 지정한다
- 그 뒤에는 개수 제한없이 인자를 쓸 수 있으며, 이들은 첫번째 인자에서 지정한 위치에서부터 배열에 삽입된다
- concat() 과 달리 배열을 있는 그대로 삽입하며 평탄화하지 않는다

```jsx
let a = [1,2,3,4,5]
a.splice(2,0,"a","b") // [], a === [1,2,"a","b",3,4,5]
a.splice(2,2, [1,2]) // ["a", "b"], a === [1,2,[1,2],3,4,5]
```

`fill()`

- fill() 메서드는 배열의 요소 또는 슬라이스를 지정된 값으로 바꾼다
- 이 메서드는 원래 배열을 수정해 반환한다
- 첫 번째 인자는 배열 요소로 사용할 값이다
- 선택 사항인 두 번째 인자는 시작 인덱스이다. 생략한다면 0 에서 시작한다
- 선택 사항인 세번째 인자는  마지막 인덱스이며 이 바로 앞까지 작업한다. 생략된다면 마지막까지 진행된다

```jsx
let a = new Array(5)
a.fill(0) // [0,0,0,0,0]
a.fill(9,1) // [0,9,9,9,9]
a.fill(8,2,-1) // [0,9,8,8,9]
```

`copyWithin()`

- 배열의 슬라이스를 복사해 새 위치에 붙여넣는다
- 이 메서드는 배열을 수정해 반환하지만 길이는 바뀌지 않는다
- 첫 번째 인자는 처음으로 복사될 위치의 인덱스이다
- 두 번째 인자는 복사할 첫 번째 요소의 인덱스이다. 생략하면 0 을 사용한다
- 세 번째 인자는 복사할 슬라이스의 끝을 지정한다. 생략하면 배열의 실이를 사용한다
- 다른 메서드와 마찬가지로 마지막 인덱스 바로 앞까지를 복사한다
- 음수를 사용하면 그 값을 배열 길이에 더해 적용한다

```jsx
let a = [1,2,3,4,5]
a.copyWithin(1) // [1,1,2,3,4]
a.copyWithin(2,3,5) // [1,1,3,4,4]
a.copyWithin(0, -2) // [4,4,3,4,4]
```

### 7.8.6 배열 검색과 정렬 메서드

- 배열의 indexOf(), lastIndexOf(), includes() 메서드는 같은 이름의 문자열 메서드와 비슷하다
- 배열 요소의 순서를 바꾸는 sort() 와 reverse() 메서드도 있다

`indexOf() 와 lastIndexOf()`

- 지정된 값을 배열에서 찾아 그 첫 번째 요소의 인덱스를 반환하며, 찾지 못하면 -1를 반환한다
- indexOf() 는 배열의 앞에서부터 검색을 시작하고 lastIndexOf() 는 배열의 뒤에서부터 역순으로 검색한다
- 두 번째 인자에서 음수를 사용하면 다른 메서드와 마찬가지로 배열 길이를 더한 값을 적용한다

 

```jsx
let a = [0,1,2,1,0]
a.indexOf(1) // 1
a.lastIndexOf(1) // 3
a.indexOf(3) // -1
```

- 문자열의  indexOf(), lastIndexOf() 메서드도 마찬가지로 동작하지만, 두 번째 인자가 음수이면 0 으로 취급한다는 점이 다르다

`includes()`

- 인자 하나를 받고 배열에 그 값이 포함되어 있으면 true를, 그렇지 않으면 false를 반환한다
- 이 메서드는 인덱스를 반환하지 않으며 그런 값이 있는지 여부만 반환한다
- indexOf() 와 중요한 차이가 있는데 인자와 배열 요소를 비교하는 알고리즘이 달라 indexOf() 는 배열에서 NaN 을 절대 찾지 못하지만, includes() 는 찾아낸다

```jsx
let a = [1,true, 3, NaN]
a.includes(true) // true
a.includes(2) // false
a.includes(NaN) // true
a.indexOf(NaN) // -1
```

`sort()`

- sort() 는 배열 요소를 정렬한다
- 인자없이 호출하면 배열 요소를 알파벳순으로 ( 필요하다면 임시로 문자열로 변환해서 ) 정렬한다
- 배열에 정의되지 않는 요소가 있다면 그들은 배열 마지막으로 밀립니다
- 알파벳이 아닌 다른 순서로 배열을 정렬하고 싶다면 반드시 sort() 에 비교 함수를 인자로 전달해야 한다
- 첫번째 인자가 두 번째보다 뒤에 있어야 한다면 함수가 0보다 큰 숫자를 반환해야 한다
- 두 값이 동등하다면 0 을 반환해야 한다

```jsx
let a = ["banana", "cherry", "apple"]
a.sort() // ["apple", "banana", "cherry"]

let b = [33, 4, 1111, 222]
a.sort((a,b) => a-b) // [4,33,222,1111]
```

`reverse()`

- 배열 요소의 순서를 거꾸로 바꾸어 반환한다
- 새 배열을 만들지 않고 기존 배열의 요소 순서를 뒤집는다

```jsx
let a = [1,2,3]
a.reverse() // [3,2,1]
```

### 7.8.7 배열을 문자열로 변환

- join() 메서드는 배열 요소 전체를 문자열로 변환한 다음, 이들을 병합한 결과를 반환한다
- 결과 문자열에서 각 요소를 구분하는 문자열을 선택 사항으로 지정할 수 있다
- 구분자를 지정하지 않으면 콤마를 사용한다
- toString() 메서드는 join() 메서드를 인자없이 호출하는 것과 동등하다

```jsx
[1,2,3].toString() // "1,2,3"
[4,5,6].join(" ") // "4 5 6"
```

- toLocaleString() 은 toString()을 지역에 맞게 바꾼 버전이다

### 7.8.8 정적 배열 함수

- Array.of() 와 Array.from() 은 새 배열을 만드는 팩토리 메서드다
- Array.isArray() 는 값이 배열인지 확인할때 유요한 메서드이다
    
    ```tsx
    Array.isArray([]) //true
    Array.isArray({}) //false
    ```
    

---

## 7.9 배열 비슷한 객체

- 자바스크립트 배열에는 다른 객체에는 없는 특별한 기능이 있다.
    - 배열에 새 요소를 추가할 때마다 length 프로퍼티를 자동으로 업데이트
    - legnth를 더 작은 값으로 변경하면 배열 요소를 그에 맞게 삭제
    - 배열은 Array.prototype 에 유용한 메서드를 상속받음
    - Array.isArray()는 배열을 받으면 true를 반환
- 하지만 이들이 배열을 정의하는 핵심 특징은 아니다
    - 숫자인 length 프로퍼티가 있고, 음이 아닌 정수 프로퍼티가 있는 객체라면 모두 일종의 배열로 간주하더라도 문제가 없다 → ArrayLike
        - 이런 객체는 실제로 자주 사용되기도 한다.
        
        ```tsx
        let a = {};
        // '배열 비슷' 해지도록 프로퍼티 추가
        let i = 0;
        while(i<10) {
        		a[i] = i * i;
        		i++;
        }
        a.length = i
        
        // 실제 배열인 것 처럼 순회함
        let total = 0;
        for(let j = 0 ; j < a.length; j++){
        		total += a[j];
        }
        ```
        

- 클라이언트 사이드 자바스크립트에는 document.querySelectorAll()처럼 HTML문서에서 배열 비슷한 객체를 반환하는 메서드가 많이 있다.
    - 아래 함수는 해당 객체를 배열처럼 쓸 수 있는지 테스트한다.
    
    ```tsx
    // 0가 배열 비속한 객체인지 판단합니다. 문자열과 함수에도 숫자인 length 프로피티가 있지만 
    // typeof 테스트에서 걸러집니다. 클라이언트 사이드 자바스크립트의 DOM Text 노드에도
    // length 프로퍼티가 있으므로 o.nodeType !== 3 테스트를 통해 거릅니다.
    function isArraylike(o) {
    		if (o && // o가 null, undefined 등이 아니고 
    				typeof o === ”object” && // 객체이며,
    				Number.isfinite(o. length) && // o.length가 유한한 숫자이고
    				o.length >= 0 && // 음이 아니며,
    				Number.isInteger(o.length) && // 정수이고
    				o.length < 4294967295) {  //2"32 - 1 미만이면
    				return true; //0는 배열 비슷한 객체입니다.
    			} else {
    					return false;
    			} 
    }
    ```
    
    - 자바스크립트 배열 메서드는 대부분 배열 비슷한 객체에서도 정확히 동작할 수 있도록 범용으로 설계되었다.
        - 배열 비슷한 객체는 Array.prototype을 상속하지 않으므로 배열 메서드를 직접적으로 호출할 수 없다.
            - [Function.call](http://Function.call) 메서드를 통해서 간접적으로 호출할 수 있다.
            
            ```tsx
            let a = {”8”; ”a”, ”1“; ”b”, ”2”: ”c”, length: 3}; // 배열 비슷한 객체 
            Array.prototype.join.call(a, ”+”) // => "a+b+c”
            Array.prototype.map.call(a, x => x.toUpperCace()) ["A","B","C"] 
            Array.prototype.slice.call(a, 0) // => ["a","b","c"] : 정확한 배열 복사
            Array.from(a) // => ["a","b","c"] : 더 쉬운 복사 방법
            ```
            
            > 그냥 Array.from() 을 사용하는게 쉽다.
            > 
            

---

## 7.10 배열인 문자열

- 자바스크립트 문자열은 UTF-17 유니코드 문자로 구성된 읽기 전용 배열처럼 동작한다
    - chatAt() 메서드 대신 대괄호를 써서 개별 문자에 접근할 수 있다.
        
        ```tsx
        let s = "test";
        s.chatAt(0) // => "t"
        s[1] // => "e"
        ```
        
- 물론 typeof 연산자는 문자열에서 “string”을 반환하며, Array.isArray() 메서드 사용시 false이다.

- 문자열이 배열처럼 동작한 다는 것은 범용 배열 메서드도 적용할 수 있다는 뜻이기도 하다.
    
    ```tsx
    Array.prototype.join.call(”JavaScript”, ” ”) // => ”J a v a S c r i p t”
    ```
    
- 문자열은 불변인 값이므로 배열처럼 취급한다 해도 읽기 전용이라는 점을 감안해야 한다.
    - push(), sort(), reverse(), splice()처럼 원래 배열을 수정하는 배열 메서드는 문자열에서 동작하지 않는다.