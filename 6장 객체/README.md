# 6장 객체

<aside>
💡 객체는 자바스크립트에서 가장 기본적인 데이터 타입이며 아주 중요한 요소이다. 명심하고 글을 읽고 이해하도록 하자.!

</aside>

## 6.1 객체 소개

- 객체는 복합된 값이다.
    - 여러가지 값 ( 기본값, 다른 객체)을 모아서 이름을 통해 값을 저장하고 가져올 수 있다.
    - 객체는 프로퍼티의 순서없는 집합이다.
        - 각 프로퍼티에는 이름과 값이 있다.
        - 프로퍼티 이름은 **보통** 문자열로 객체가 문자열에 값을 연결한다고 볼 수 있다.
        
- 문자열과 값을 연결하는 동작을 다른 언어에서는 해시 , 해시 테이블, 딕셔너리, 연관 배열같은 이름으로 부르기도 한다.
    - 그러나! 객체는 단순이 문자열과 값을 연결한 것 뿐만이 아닌 `프로토 타입/프로토타입 상속` 이라는 중요한 기능이 포함되어 있다.
    
- 자바스크립트에서 `문자열, 숫자, 심벌, true, false, null, undefined`가 아닌 값은 모두 객체에다.
    - 문자열, 숫자, 불은 객체가 아니지만 불변인 객체처럼 행동할 수 있다.

`프로퍼티`

- 프로퍼티에는 이름과 값이 있으며, 프로퍼티 이름에는 빈 문자열과 심벌을 포함해 어떤 문자열이든 쓸 수 있지만, 같은 이름의 프로퍼티는 존재할 수 없다.
    
    `own property`
    
    - 프로토타입 객체에서 상속되지 않은 객체의 자체 프로퍼티

`프로퍼티 속성`

- 쓰기가능
    - 프로퍼티에 값을 설정할 수 있는지 없는지를 나타낸다.
- 열거 가능
    - for/in 루프에 프로퍼티 이름을 반환할지 안할지를 나타낸다.
- 변경 가능
    - 프로퍼티를 삭제할 수 있는지 없는지, 속서응ㄹ 바꿀수 있는지 없는지를 나타낸다.
    
    <aside>
    💡 자바스크립트 내장 객체의 프로퍼티중 상당수는 읽기 전용이거나 열거 불가, 변경불가이다.
    
    </aside>
    
    > 우리가 직접 만드는 객체의 프로퍼티는 기본적으로 쓰기, 열거, 변경 가능하다.
    > 

---

## 6.2 객체 생성

- 객체를 생성할 때는 객체 리터럴, new 키워드, Object.create() 함수를 사용한다.

### 6.2.1 객체 리터럴

- 객체를 생성하는 가장 쉬운 방법이다.

```tsx
let emtpy = {};
let point = { x : 0, y: 0};
let p2 = { x: point.x, y: point.y+1 }
```

- 객체 리터럴을 평가할 때마다 새 객체가 만들어진다.
    - 각 프로퍼티의 값 역시 리터럴을 평가할 때마다 평가된다
        - 따라서 객체 리터럴 자체가 바뀌지 않더라도 반복적으로 호출되는 함수나 루프바디 안에 있다면 새 객체를 여러개 만들 수 있다.
        

### 6.2.2 new

- new 연산자는 새 객체를 생성하고 초기화한다
    - new 키워드 뒤에는 반드시 함수 호출이 있어야한다.
        - 이런 형태로 사용하는 함수를 생성자라고 부르고, 새로 생성된 객체를 초기화 하는 목적으로 사용한다.

### 6.2.3 프로토타입

- 자바스크립트 객체 거의 대부분은 자신과 연결된 **두번째 객체**를 갖는다.
    - 이 두번째 객체를 `프로토타입` 이라고 부르며, 첫번째 객체는 프로토타입에서 프로퍼티를 상속한다.

- 객체 리터럴을 사용해 생성된 객체는 모두 값은 프로토타입 객체를 가지며, `Object.prototype` 이라는 코드로 참조할 수 있다.

- new 키워드와 생성자를 사용해 만든 객체는 생성자 함수의 prototype 프로퍼티값을 자신의 프로토타입으로 사용한다
    - 따라서 new Object() 로 생성한 객체는 {} (객체 리터럴) 로 생성한 객체와 마찬가지로 Object.prototype에서 상속한다.

- Object.prototype은 프로토타입이 없는 드문 객체중 하나이다
    - 이 객체는 어떤 프로퍼티도 상속하지 않는다
    - 다른 프로토타입 객체는 프로토타입이 있다.
        - 예를 들어 Date.prototype은 Object.prototype에서 프로퍼티를 상속함으로 new Date()를 통해 만든 객체는 Date.prototype, Object.prototype 모두 프로퍼티를 상속한다.
            - 이렇게 이어지는 프로토타입 객체 사이의 연결을 프로토타입 체인이라 부른다.

### 6.2.4 Object.create()

- Object.create()는 첫번째 인자를 프로토타입 삼아 새 객체를 생성한다.
    
    ```tsx
    let ol = Object.create({x: 1, y: 2}); // ol은 X와 y 프로퍼티률 상속합니다.
    ol.x + ol.y // => 3
    ```
    
    - new Object 처럼 일반적인 빈 객체를 만들고 싶을떄는 Object.prototype을 전달한다.
        
        ```tsx
        let o3 = Object.create(Object.prototype) // o3는 {}나 new Object()와 같습니다.
        ```
        

`주 사용 목적`

- 서드파티 라이브러리에서 객체를 변경하는 사고를 막기 위함
    
    ```tsx
    let o ={x: ”don’t change this value” }; 
    library.function(Object.create(o)); // 의도치 않온 번경에 대한 방어
    ```
    

---

## 6.3 프로퍼티 검색과 설정

- 프로퍼티 값에 접근할 때는 . 이나 [] 연산자를 사용한다
    - 점 연산자를 사용한다면 오른쪽은 반드시 프로퍼티 이름인 단순한 식별자여야 한다
    - 대괄호를 사용한다면 그 안에 있는 값은 원하는 프로퍼티 이름인 문자열로 평가되는 표현식이어야 한다
    - 프로퍼티를 생성하거나 설정할때도 마찬가지이다

```jsx
let author = book.author
let name = author.surname
let title = book["main title"]

// 프로퍼티 생성
book.edition = 7
book["main title"] = "ECMAScript"
```

### 6.3.1 연관 배열인 객체

- object[”property”] 처럼 문자열을 인덱스로 사용하는 배열을 연관 배열이라 부른다
- 또는 hash, map, dictionary 라고 부르기도 한다
    
    ⇒ 자바스크립트에서 객체는 연관 배열이다
    
- 자바스크립트는 타입을 엄격하게 고정하지 않아서 어떤 객체에든 프로퍼티를 얼마든지 생성할 수 있다
    - 대괄호 연산자로 객체 프로퍼티에 접근할때 문자열로 접근하는데 문자열은 자바스크립트 데이터 타입이므로 프로그램이 실행되는 동안 새로 생성할 수 있고 조작할수도 있다
    - C나 자바와 같이 식별자로만 표현되면 식별자는 데이터 타입이 아니므로 프로그램에서 조작할 수 없다
- 대괄호 연산자는 동적이고 런타임에 바꿀 수 있는 문자열 값을 사용한다
- for/in 루프는 연관 배열(=객체)과 함께 사용할 때 더 강력하다

```jsx
function computeValue(portfolio) {
	let total = 0.0
	for(let stock in portfolio) {
		let shares = portfolio[stock]
		let price = getQuote(stock)
		total += shares * price
	}
	return total
}
```

### 6.3.2 상속

- 자바스크립트 객체에는 자체 프로퍼티도 있고, 프로토타입 객체에서 상속하는 프로퍼티도 있다
- 객체는 자신의 자체 프로퍼티에서 접근하려는 프로퍼티를 찾을 수 없다면 프로토타입 객체에서 해당 프로퍼티를 검색하며 찾아 올라간다
- 객체의 프로토타입 속성은 자신이 어디에서 프로퍼티를 상속했는지 나타내는 체인을 형성한다

```jsx
let o = {}
o.x = 1
let p = Object.create(o)
p.y = 2
let q = Object.create(p)
q.z = 3
let f = q.toString() // Object.prototype
q.x + q.y // 3, x,y는 o와 p에서 상속함
```

- 상속받은 프로퍼티에 값을 할당한다면, 상속된 프로퍼티는 이제 새로 생성된 자체 프로퍼티에 가려진다
- 프로퍼티 할당은 프로토타입 체인을 검색해 할당이 허용되는지 확인한다
    - 읽기전용인 프로퍼티를 상속한다면 할당은 허용되지 않는다
    - 할당이 허용된다면 항상 원래 객체에 프로퍼티를 생성하거나 설정할 뿐, 프로토타입 체인에 존재하는 객체는 절대 수정하지 않는다
    
    ⇒ 프로퍼티를 검색할 때는 상속을 감안하지만, 설정할 때는 그렇지 않으므로 상속된 프로퍼티도 덮어쓸수 있다
    
    ```jsx
    let circle = {r:1}
    let c = Object.create(circle)
    c.x = 1
    c.y = 1
    c.r = 2 // 자체 프로퍼티로 덮어쓰기
    circle.r // 1 : 프로토타입은 영향받지 않는다
    ```
    
- 상속받은 프로퍼티가 세터 메서드가 있는 접근자 프로퍼티라면 자체 프로퍼티를 새로 만드는 대신 세터 메서드를 호출한다
    - 하지만 세터 메서드는 상속받은 객체에서 호출되는 것이지 프로토타입 객체에서 호출되는 것이 아니므로, 세터 메서드가 프로퍼티를 변경하더라도 상속받은 객체에 변화가 있을뿐 프로토타입 체인은 변하지 않는다

### 6.3.3 프로퍼티 접근 에러

- 프로퍼티 접근 표현식이 항상 값을 반환하거나 설정하는 것은 아니다
- 존재하지 않는 프로퍼티를 검색하는 것은 undefined로 평가되지 에러는 아니다
- 존재하지 않는 객체의 프로퍼티를 검색하려는 것은 에러다

```jsx
let len = book.subtitle.length // TypeError: undefined 에는 length 프로퍼티가 없습니다

// 이런 문제에 대응하는 3 가지 방법

// 1. 장황하지만 명시적인 방법
let surname = undefined
if(book) {
	if(book.author) {
		surname = book.author.surname
	}
}

// 2. 관용적 표현식 사용
surname = book && book.author && book.author.surname

// 3. 조건부 프로퍼티 접근 연산자 사용
let surname = book?.author?.surname
```

- null이나 undefined의 프로퍼티를 설정하려고 해도 TypeError 가 일어난다
- 다른 값에 프로퍼티를 설정하려 해도 항상 성공하는 것은 아니다
    - 읽기 전용인 프로퍼티 일수도 있고 객체가 프로퍼티 추가를 허용하지 않을 수도 있다
- 스트릭트 모드에서는 프로퍼티를 설정하려다 실패하면 TypeError 가 일어난다

---

## 6.4 프로퍼티 삭제

- delete 연산자는 객체에서 프로퍼티를 삭제한다
    - 피연산자는 프로퍼티 접근 표현식이어야 한다
    - 값을 삭제하는 것이 아니라 프로퍼티 자체를 삭제한다
    - 자체 프로퍼티만 삭제할 뿐 상속된 프로퍼티는 삭제하지 않는다
        
        → 상속된 프로퍼티를 삭제하려면 반드시 해당 프로퍼티를 정의한 프로토타입 객체에서 삭제해야 한다
        
        ⇒ 이렇게 하면 해당 프로토타입을 상속한 객체 전체에 영향을 미친다
        
- delete 표현식은 삭제에 성공했을때, 존재하지 않는 프로퍼티 삭제를 시도하거나 접근 표현식이 아닌 표현식을 사용했을 때도 true 로 평가된다
- delete 는 변경 가능 속성이 false 인 프로퍼티는 제거하지 않는다
    - 내장 객체의 일부 프로퍼티, 변수 선언이나 함수 선언으로 생성된 전역 객체의 프로퍼티는 변경 불가이다
- 스트릭트 모드에서 변경 불가인 프로퍼티를 삭제하려 하면 TypeError가 일어난다
    - 일반 모드에서는 에러가 일어나지 않고 false로 평가된다

---

## 6.5 프로퍼티 테스트

- 자바스크립트 객체에서 주어진 이름을 가진 프로퍼티가 객체에 존재하는지 확인해야 될때가 있다.
    - 이 경우 in 연산자, hasOwnProperty(), propertyIsEnumerable() 을 이용하거나 그냥 검색을 한다.
        - in 연산자는 왼쪽에 프로퍼티 이름, 오른쪽에 객체를 예상한다.
            
            ```tsx
            let o = { x: 1 };
            ”x” in o // => true: 0에는 자체 프로퍼티 X가 었습니다. 
            ”y” in o // => false: o에는 프로퍼티 y가 없습니다. 
            "toString” in o // => true: 0는 toString올 상속합니다.
            ```
            
        - hasOwnProperty() 메서드는 객체에 주어진 이름을 가진 자체 프로퍼티가 있는지 테스트한다.
            - 상속된 프로퍼티에는 false를 반환하니 주의하기
            
            ```tsx
            let o = { x: 1 };
            o.hasOwnProperty(”x“) // => true: 0에는 자체 프로퍼티 X가 있습니다. 
            o.hasOwnPrope「ty(”y”) //=> false: o에는 프로퍼티 y가 없습니다. 
            o.hasOwnProperty(“toString”) // => false: toString은 상속된 프로떠티입니다.
            ```
            
        - propertyIsEnumerable()은 hasOwnProperty()보다 더 제한된 버전이다.
            - 지정된 프로퍼티가 자체 프로퍼티이며, 열거 가능속성이 true일때만 true를 반환한다.
                
                ```tsx
                let o = { x: 1 };
                o.propertyisEnumerable(”x”) // => true: 0 에는 열거 가능 프로퍼티 X가 있습니다. 
                o.propertyisEnumerable(”toString")//=> false: 자체 프로퍼티가 아닙니다.
                Object. prototype. propertyisEnumerable(“toString") // => false: 얼거 불가입니다.
                ```
                
        - 그냥 프로퍼티를 검색하고 !== 를 이용해 undefined가 아님을 확인할 수도 있다.
            
            ```tsx
            let o = { x: 1 } ;
            o.x !== undefined //=> true: 0에는 프로퍼티 X가 있습니다. 
            o.y !== undefined // => false: 0에는 프로퍼티 y가 없습니다. 
            o.toString !== undefined // => true: 0는 toString을 상속합니다.
            ```
            

---

## 6.6 프로퍼티 열거

> 객체의 프로퍼티 전체를 순회해야 하는 경우의 방법을 설명한다.
> 

`for/in`

- 열거 가능한 프로퍼티를 연속적으로 루프 변속에 할당한다.
    - 열거 불가능한 프로퍼티는 할당하지 않는다.
    
    ```tsx
    let o = {x: 1, y: 2, z: 3}; 
    o.propertyisEnumerable(”toString") // 1 => false: 열거 불가 
    for(let p in o) {
    console.log(p); // x, y, z를 출력하지만 toString은 아닙니다.
    }
    ```
    
    - for/in에서 상속된 프로퍼티가 열거되는 것을 막을때는 명시적으로 루프바디 안에서 체크한다.
    
    ```tsx
    for(let p in o) {
     if(!o.hasOwnProperty(p)) continue; // 상속된 프로떠티는 건너뜁니다.
    }
    
    for(let p in o) {
    if (typeof o[p] === ” function”) continue; // 메서드는 건너됩니다.
    }
    ```
    

`for/of`

- `for/in` 을 사용하는 것보다는 객체의 프로퍼티 이름을 배열에 저장한 뒤, for/of 루프를 사용하는것이 더 쉬울때가 많다.
    - 프로퍼티 이름을 배열로 저장할 수 있는 함수는 `Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Reflect.ownKeys()` 네가지가 있다.
    

### 6.6.1 프로퍼티 열거 순서

- 객체의 자체 프로퍼티를 열거하는 순서는 ES6에서 공식적으로 정의하였다.
    1. 이름이 음이아닌 정수인 문자열 프로퍼티가 첫번째로 나열되며, 작은수에서 큰 수 순으로 열거된다.
        - 따라서 배열, 유사배열객체의 프로퍼티도 순서대로 열거된다.
    2. 배열 인덱스와 비슷한 프로퍼티를 모두 열거한 다음, 음수나 부동소수점숫자처럼 보이는 프로퍼티를 포함에 이름이 문자열인 프로퍼티를 열거한다.
        - 이는 객체에 추가된 순서대로 열거된다.
            - 객체 리터럴로 정의된 프로퍼티는 리터럴에 쓰인 순서를 따른다.
    3. 이름이 심벌인 프로퍼티를 객체에 추가된 순서대로 열거한다.
    

---