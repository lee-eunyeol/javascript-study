# 4장 표현식과 연산자

- 표현식
    - 어떤 값으로 평가되는 구절
    - 상수, 변수
- 연산자
    - 피연산자(보통 두 개)의 값을 어떤 형태로 조합해 새 값으로 평가

## 4.1 기본 표현식

- 가장 단순한 표현식. 단독으로 존재함
    - 리터럴 - 문자 그대로 쓰는 값
    - 예약어 - true, false, null, this
    - 변수, 상수, 전역 객체의 프로퍼티에 대한 참조
        - 존재하지 않는 변수를 평가하려고 하면 ReferenceError 가 일어남

## 4.2 객체와 배열 초기화 표현식

- 그 값이 새로 생성된 객체나 배열인 표현식 = 객체/배열 리터럴
- 리터럴과 달리 초기화 표현식은 프로퍼티와 요소 값을 지정하는 다양한 하위 표현식으로 구성되므로 기본 표현식은 아님

```jsx
/* 배열 초기화 표현식 */
[]
[1+2, 3+4]
[1,,,5] //1,5를 제외한 나머지는 undefined로 평가됨

/* 객체 초기화 표현식 */
let q = {}
let p = {x: 2.3, y: -1.2} 
q.x = 2.3; q.y = -1.2 
```

## 4.3 함수 정의 표현식

- 함수를 정의하며 그 값은 함수임
- 함수 정의 표현식을 함수 리터럴이라고 부를 수도 있음
- function 키워드로 시작하거나 화살표 함수 문법을 쓸 수도 있음

```jsx
let square = function(x){
	return x * x
}

let square2 = (x) => x * x
```

## 4.4 프로퍼티 접근 표현식

- 객체 프로퍼티나 배열 요소의 값으로 평가됨
- 자바스크립트에는 두 가지 프로퍼티 접근 문법이 있음
    - expression.identifier
    - expression[”identifier”]

### 4.4.1 조건부 프로퍼티 접근

- ES2020에서 새로운 프로퍼티 접근 표현식 두 가지를 추가했다
    - expression?.identifier
    - expression?.[”identifier”]
- 자바스크립트에서 프로퍼티를 가질 수 없는 값은 null과 undefined 인데 프로퍼티에 접근하려는 값이 null 과 undefined 일 경우에 발생하는 TypeError를 막을 수 있다
- ?. 의 왼쪽에 있는 하위 표현식이 null 이나 undefined 로 평가되면 더는 프로퍼티에 접근하려 시도하지 않고 전체 표현식을 즉시 undefined로 평가한다

## 4.5 호출 표현식

`호출 표현식` : 함수나 메서드를 호출(실행)하는 문법

```tsx
f(0) // 는 함수 표현식이고 0은 인자 표현식입니다. 
Math.max(x,y,z) //Math.max는 함수이고 x, y, 는 인자입니다. 
a.sort() // a.sort 는 함수이고 인자는 없습니다.
```

- 호출 표현식 평가
    1. 함수 표현식(ex `f()`) 평가
        1. 값이 함수가 아니라면 Type Error를 일으킨다.
    2. 함수 인자표현식(ex `0`)평가
        1. 인자를 지정된 함수의 매개변수에 순서대로 할당한 다음, 함수 바디를 실행
    - 함수가 return문을 통해 값을 반환하면 그 값이 함수의 값
        - 그렇지 않다면 함수의 값은 undefined

- 호출 표현식 맨 앞에 있는 표현식이 프로퍼티 접근 표현식이라면, 이 호출은 메서드 호출이라고도 한다.
    
    ```tsx
    a.f(0) // f() 메서드 호출
    ```
    

### 4.5.1 조건부 호출

- ES2020부터는 `()` 대신 `?.()` 를 통해 함수를 호출하여 괄호 왼쪽의 표현식이 null이나 undefined일 경우 TypeError를 발생시키지 않고 호출 표현식 전체를 undefined로 평가해준다.
    
    ```tsx
    function squae(x, log) { // 두 번째 인자는 선택 시항인 함수입니다. 
    log?.(x); // 함수를 받았으면 호출합니다. 
    return x * x;// 인자의 제곱을 반환합니다.
    ```
    
    - 그러나 `?.()` 는 왼쪽에 있는 것이 null , undefined인지만 체크하고 **함수인지는 체크하지 않기 때문**에 이와 같은 에러는 똑같이 발생하다.
    

<aside>
💡 조건부 프로퍼티 접근, 조건부 호출에 대해 확실히 이해하고 넘어가자

</aside>

---

## 4.6 객체 생성 표현식

`객체 생성 표현식` : 호출 표현식과 같지만, 그 앞에 new 키워드를 붙인다

 

```tsx
new Object()
new Point(2,3)
```

- 객체 생성 표현식에서 생성자 함수에 전달할 인자가 없다면 괄호는 생략 가능하다.

```tsx
new Object
new Point
```

---

## 4.7 연산자 개요

- 연산자는 산술, 비교, 논리 ,할당 표현식등에 사용된다.
    - 대부분의 연산자는 + 나 = 처럼 부호로 표현된다.
        - delete 나 instance of 같은 키워드 연산자도 있다 (단지 문법이 덜 간결할 뿐이다.)

### 4.7.1 피연산자 개수

- 연산자를 예상하는 피연산자 개수를 기준으로 분류 할 수 있다.
    - 자바스크립트 연산자 대부분은 곱셈 연산자 `*`처럼 표현식 두개를 조합해 하나로 만드는 2항 연산자다. ( 피연산자가 두개다)
    - `-x` (부호변경) 과 같은 단항 연산자도 있다.
    - `? :` (조건 연산자) 과 같은 3항 연산자도 있다.
    

### 4.7.2 피연산자와 결과 타입

- 자바스크립트 연산자는 필요에 따라 피연산자의 타입을 변환한다.
    - 곱셈 연산자는 피연산자가 숫자일 거라고 예상하지만 `“5” * “3”` 또한 피연산자를 숫자로 변환하여 계산하기 떄문에 유효한 표현식이다.
        - 위 예시의 결과값은 “15” 가 아닌 숫자 15이다.
    
    - 피연산자 타입에 따라 다르게 동작하는 연산자도 있다.
        - 대표적으로 `+`
            - 숫자이면 더하고, 문자열이면 문자를 병합한다.
            

### 4.7.3 연산자와 부수 효과

- 할당 연산자(`=`)와 같이 이후의 평가 결과에 영향을 미치는 부수효과(Side Effect)를 가진 연산자가 있다.
    - 변수나 프로퍼티에 값을 할당하면, 해당 값을 사용하는 모든 표현식에 영향을 미침
    - 증가/감소 연산자 (`++` , `--` ) 역시 묵시적으로 항당의 역할을 함으로 비슷한 영향을 미침
    - delete 연산자도 해당 프로퍼티에 undefind를 할당하는것과 비슷하다.

### 4.7.4 연산자 우선순위

- 연산자 우선순위는 동작 순서를 결정한다

> 수학시간
> 

```tsx
w = x + y*z
```

- 위의 경우 `*` 연산자가 `+` 연산자보다 우선순위가 높기 때문에 `*` 연산자 먼저 실행된다.

- 괄호를 사용해서 연산자 우선순위를 덮어 쓸 수 있다.

```tsx
w = (x+y)*z
```

<aside>
💡 현실에서 연산자 우선순위가 불확실하다면 괄호를 사용해서 순서를 명시적으로 정하자

</aside>

### 4.7.5 연산자 결합성

`좌결합성` : 왼쪽에서 오른쪽으로 연산

`우결합성` : 오른쪽에서 왼쪽으로 연산

- 좌결합성 연산 예시
    
    ```tsx
    w = x - y - z;
    
    w = ((x - y) -z);
    ```
    

- 우결합성 연산 예시
    
    ```tsx
    y = a ** b ** c; 
    x = ~-y; 
    w = x = y = z; 
    q = a?b:c?d:e?f:g;
    -->
    y = (a ** (b ** c)); 
    x = ~(-y); 
    w = (x= (y= z)); 
    q = a?b:(c?d:(e?f:g));
    ```
    
    - 시수,단항,할당,조건(3항) 연산자는오른쪽에서 왼쪽으로 수행한다.

### 4.7.6 평가 순서

- 연산자 우선순위와 연관성은 복잡한 표현식에서 어떤 순서로 동작이 수행되는지는 지정하지만, 하위 표현식이 평가되는 순서를 지정하지 않는다.
    - **자바스크립트에서는 항상 표현식을 왼쪽에서 오른쪽으로 평가한다.**
        - w = x + y * z 표현식
        1. 하위표현식 w 평가
        2. x, y, z 평가
        3. y 와 z 의 값을 곱한다
        4. x의 값을 더한다.
        5. 표현식 w에서 지정한 변수나 프로퍼티에 할당