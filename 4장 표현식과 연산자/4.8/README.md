# 2주차

## 4.8 산술 표현식

- 기본 산술 연산자 `**, *, /, %, +, -`
    - `**` 연산자는  `*, /, %` 보다 우선순위가 높으며 세 연산자는 다시 `+,-` 보다 운선순위가 높다
    - `**` 연산자는 Math.pow() 함수와 정확히 같은 동작을 한다

### 4.8.1 + 연산자

- 2항 연산자  `+` 는 숫자 피연산자는 더하고 문자열 피연산자는 병합한다

- `+` 연산자 변환 규칙
    - 동작 규칙
        
        ```tsx
        1+2 //=>3: 덧셈
        ”1” + ”2”// => ’12'’: 병합
        ”1” + 2 // => ”12”; 숫자를 문자열로 변환한 후 병합
        1 + {} //”1[object Object]’': 객체률 문자열로 변환한 후 병합 
        true + true // => 2: 불 값을 숫자로 변환한 후 덧셈
        2 +null // => 2: null을 0으로 변환한 후 덧셈
        2 + undefined // =>NaN: undefined를 N빼으로 변환한 후 덧셈
        ```
        
        - 문자열 병합에 우선순위가 있다.
        - 객체의 경우 기본값으로 변환하는 알고리즘을 사용해 변환후, 더한다.
            - valueOf() 또는 toString()이 호출됨
- 주의점
    
    ```tsx
    1 + 2 + ” blind mice" // => ”3 blind mice“ 
    1 + (2 + ” blind mice“) // => ”12 blind mice"
    ```
    
    - `+` 연산자의 동작순서에 따라 결과가 달라질 수 있으니 괄호를 이용하여 동작 순서를 결정할 수 있다.

### 4.8.2 단항 산술 연산자

- 단항 연산자는 피연산자 하나의 값을 바꿔 새 값을 얻는다.

`단항 플러스(+)`

- 단항 플러스 연산자는 피연산자를 숫자로 변환한 값을 반환한다.

`단항 마이너스(-)`

- 피연산자를 숫자로 변환한 다음 부호를 바꾼다.

`증가(++)`

- `++` 연산자는 피연산자에 1을 더하며, 피연산자가 숫자가 아닐경우 숫자로 변환하고, 1을 더한다음 다시 피연산자에게 할당한다.
    - `++` 연산자의 반환 값은 피연산자와 연산자의 위치관계에 따라 다르다
    
    ```tsx
    let i = 1, j = ++i; // i , j 모두 2
    let n = 1, m = n++; // n은 2 m은 1 --> m은 n에 1을 더하기 전인 값으로 평가
    ```
    

- x++ 과 x= x+1이 항상 같은건 아니다.
    - x가 문자열 “1” 일경우
        - x++ 은 숫자 변환이 있기 때문에 2
        - x = x + 1 은 문자 변환이 일어나기 때문에 “11”

`감소(--)`

- `--` 연산자는 `++` 연산자와 반대로 1을 빼고 피연산자에 할당한다.

### 4.8.3 비트 연산자

- 비트 연산자는 수자의 이진표현의 비트를 대상으로 저수준 조작을 수행한다.
    - 숫자 피연산자를 받고 숫자값을 반환하므로 산술연산자로 분류된다.
    
    > 비트연산자는 자바스크립트 프로그래밍에서 널리 쓰이지는 않는다.
    > 

- 비트 연산자는 피연산자에 정수값을 예상하며, 64비트 부동소수점 값이 아닌, 32비트 정수인 것처럼 동작한다.
    - 따라서 비트 연산자는 피연산자를 32비트 정수로 강제 변환한다.
    

`비트 AND(&)`

- `&` 연산자는 피연산자 정수 각 비트에 불 AND 연산을 수행한다
    
    ```tsx
    0x1234 & 0x00FF === 0x0034
    ```
    

`비트 OR( | )`

- `|` 연산자는 피연산자인 정수의 각 비트에 불 OR 연산을 수행한다.
    
    ```tsx
    0x1234 | 0x00FF === 0x12FF
    ```
    

`비트 XOR(^)`

- `^` 연산자는 각 비트에 불 XOR 연산을 수행한다.
    - XOR은 둘다 true일 경우 0 을 반환하되 나머지는 `OR` 연산자와 같다.
    
    ```tsx
    0xFF00 ^ 0xF0f0 === 0x0FF0
    ```
    

`비트 NOT(~)`

- ~ 연산자는 정수 피연산자 하나만 받으며, 피연산자의 비트를 모두 반대로 뒤집는다.

> 이외 시프트의 경우 활용도면에서 낮다고 생각하고, 필요할 경우 찾아보면 될것 같아 정리하지 않음
> 

---

## 4.9 관계 표현식

- 관계 연산자는 두값 사이의 관계를 나타내며, 그런 관계에 따라 false 또는 true를 반환한다.

### 4.9.1 일치와 불일치 연산자

`일치 연산자(===)`

- 두 피연산자가 **완전히 일치하는지** 체크한다.
- 동작 규칙
    - 두값이 다른 타입이면 같은값이 아님
    - 두값이 모두 null이거나 모두 undefined 이면 같은 값
    - 두값이 모두 true이거나 false 이면 같은 값
    - 두값 중 하나라도 NaN이면같은값이 아닙니다.NaN은자기
        
        자신을포함해 어떤 값과도 같지 않다 
        
        > 값 x가 NaN인지 체크하려면 x !== x 를 쓰거나 전역 함수 isNaN()을 쓰자
        > 
    - 두 값이 모두 문자열이고 같은 위치에 정확히 같은 16비트 값을 포함한다면같은 값
    - 두 값이 같은 객체, 배열, 함수를 참조한다면 같은 값
        - 다른 객체를 참조 한다면 다른 값
            - 설령 두 객체의 프로퍼티가 일치한다 해도 다른 값

`동등 연산자(==)`

- 타입변환을 허용함으로 두 피연산자가 **같다고 볼 수 있는지** 체크한다.
- 동작 규칙
    - 두 값이 같은 타입이라면 위에서 설명한 대로 일치하는지 체크
    - 두 값이 다르다면, 타입 변환을 수행한 후 다시 비교

### 4.9.2 비교 연산자

`미만(<)`

- `<` 연산자는 피 연산자가 두번째 피연산자보다 작으면, true 크면 , false

`초과(>)`

- `<` 연산자와 반대

`이하(<=) / 이상(>=)`

- 미만, 초과 연산자에서 **“같으면”** 이라는 조건이 붙는다.

- 위 비교연산자들은 피연산자의 타입을 가리지 않는다.
    - 대신, 비교는 숫자와 문자열에 대해서만 가능하므로 숫자, 문자열이 아닐경우 문자열로 변환한다.
    - 동작 규칙
        - 피연산자가 객체일 경우 기본값으로 변환 (toString(), valueOf())
        - 객체를 기본값으로 변환한 후 두 피연산자가 모두 문자열이면 문자열 비교 수행
            - 문자열 비교방법 : 문자열을 구성하는 16비트 유니코드값의 숫자 순서
        - 문자열이 아닌 피연산자가 있다면 모두 숫자로 변환한 후 비교
    
    - `+` 연산자와 비교 연산자의 차이
        - `+` 연산자는 변환시 문자열 선호
        - 비교 연산자는 변환시 숫자 선호
        
        ```tsx
        1 + 2 // => 3: 덧셈
        "1" + "2" // => "12": 병합
        "1" + 2 // => "12": 2는 "2"로 변환
        "11"< 3 // => false: 숫자 비교. "11"은 11로 변환
        ```
        

### 4.9.3 in 연산자

- `in` 연산자는 왼쪽 피연산자가 문자열, 심벌, 숫자로 변환될 수 있는 값이라고 예상하고 오른쪽 피연산자는 객체라고 예상한다
- 왼쪽 피연산자가 오른쪽 객체의 프로퍼티 이름일 경우 true 를 반환한다

```jsx
let point = { x:1, y,1 }
"x" in point // true
"z" in point // false
"toString" in point // true

let data = [7,8,9]
"0" in data // true
1 in data // true
3 in data // false
```

### 4.9.4 instanceof 연산자

- `instanceof`는 왼쪽 피연산자가 객체, 오른쪽 피연산자는 객체의 클래스라고 예상한다
- 왼쪽에 있는 객체가 오른쪽에 있는 클래스의 인스턴스라면 true, 아니라면 false를 반환한다
- instanceof는 객체가 클래스의 인스턴스인지 판단할때 슈퍼클래스를 감안한다
    - 객체는 모두 Object의 인스턴스
- 동작원리를 이해하려면 프로토타입 체인을 이해해야 함!

---

## 4.10 논리 표현식

### 4.10.1 불 AND (&&)

- && 연산자는 피연산자 중 하나라도 false 이면 false를 반환, 모두 true 일 때만 true를 반환한다
- &&는 피 연산자가 불 값을 가질 것을 요구하지 않는다. 자바스크립트 값은 모두 true 같은 값 또는 false 같은 값으로 해석할 수 있기 때문이다
- 왼쪽에 있는 값이 false 같은 값이면 왼쪽 값을 반환, true 같은 값이면 오른쪽에 있는 값을 반환한다
    - 이런 동작 방식을 단축 평가 (short circuit) 라고 부른다
    - 코드를 조건부로 실행하려 할 때 사용하기도 한다

```jsx
// 두 행의 효과는 동일하다
if(a === b) stop()
(a === b) && stop()
```

### 4.10.2 불 OR (||)

- || 연산자는 피연산자중 하나라도 true 같은 값의면 true를 반환, 모두 false 같은 값이면 false를 반환한다
- 왼쪽에 있는 값이 true 같은 값이면 단축평가가 일어나서 바로 true 값을 반환하고, false 같은 값이면 두번째 피연산자를 평가하고 그 값을 표현식의 값으로 반환한다
- 이 연산자는 몇가지 변수 중에서 첫번째로 등장하는 true 같은 값을 선택하려고 할 때 자주 사용한다

### 4.10.3 불 NOT (!)

- ! 연산자는 단항 연산자이므로 단일한 피연산자 앞에 사용한다
- 이 연산자의 목적은 피연산자의 불 값을 부정하는 것이다. 피연산자를 불값으로 변환한 다음 부정한다
- ! 는 항상 true 또는 false 를 반환한다
- ! 는 단항 연산자이므로 우선순위가 높고 피연산자와 단단히 결합된다

```jsx
// 드 모르간의 법칙
!(p && q) === (!p || !q) // true
!(p || q) === (!p && !q) // true
```

## 4.11 할당 표현식

```jsx
i = 0
o.x = 1
```

- = 연산자는 왼쪽 피연산자가 왼쪽 값, 즉 변수나 객체 프로퍼티 또는 배열 요소인것으로 예상한다
- 오른쪽 피연산자는 어떤 타입이든, 어떤 값이든 상관없다
- = 의 우선순위는 아주 낮아서 더 큰 표현식에서 사용하고자 할 때는 보통 괄호가 필요하다

```jsx
(a = b) === 0
```

- 할당 연산자의 결합성은 오른쪽에서 왼쪽이다. 표현식 하나에 할당 연산자가 여럿 존재한다면 이들은 오른쪽에서 왼쪽으로 평가한다

```jsx
i = j = k = 0 //세 변수를 모두 0으로 초기화
```

### 4.11.1 할당과 연산

- 자바스크립트는 일반적인 = 할당 연산자 외에도 할당 연산자와 다른 연산자를 결합한 단축 표현을 지원한다

![스크린샷 2023-03-12 20.55.39.png](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fc0365ff078a4ba6ad4ffc00a8aebb2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-12_20.55.39.png)

```jsx
data[i++] *= 2
data[i++] = data[i++] * 2
// 두 할당 표현식은 동등하지 않다는 것이 잘 이해가 안됨
```

## 4.12 평가 표현식

- 문자열을 자바스크립트 소스 코드로 해석하고 평가해서 값을 얻을 수 있다
- 전역 함수 eval()이 그 역할을 담당한다

### 4.12.1 eval()

- eval() 은 인자를 하나 받는다. 문자열이 아닌 값을 전달하면 그 값을 반환한다
- 문자열을 전달하면 그 문자열을 자바스크립트 코드로 분석할 수 있는지 시도하고, 실패하면 SyntaxError 를 일으킨다
- eval() 은 자신을 호출한 코드의 변수 환경을 사용한다
- let 이나 const 를 사용한다면 해당 변수가 상수는 평가 컨텍스트에 종속되며 호출하는 환경에는 정의되지 않는다

### 4.12.2 전역 eval()

- eval()은 로컬 변수를 엉망으로 만들어서 자바스크립트 최적화기를 곤란하게 만든다
- eval() 을 호출하는 함수에 대해서 적극적으로 최적화 하지 않는다
    - 성능에 좋지 않아서 사용하지 않는 것이 좋다
    

### 4.12.3 스트릭트 eval()

- 스트릭트 모드는 eval() 함수를 더 제한하고 eval 이라는 식별자의 사용 역시 제한단다
- eval 이라는 이름으로 변수, 함수, 매개변수를 선언할 수 없고 블록을 캐치할수 없다

## 4.13 기타 연산자

### 4.13.1 조건 연산자 (?:)

- 조건 연산자는 자바스크립트에서 유일한 3항 연산자이며 실제로 3항 연산자라고 불린다
- 조건 연산자는 피연산자의 타입을 가리지 않고 첫번째 피연산자를 불로 평가하고 해석한다
- 첫번째 피연산자의 값이 true 같은 값이면 두번째 피연산자를, 그렇지 않으면 세번째 피연산자를 평가하고 그 값을 반환한다

```jsx
x > 0 ? x : -x //x 의 절대값
```

### 4.13.2 null 병합 연산자 (??)

- 첫번째 피연산자가 null이나 undefined로 평가될때만 두번째 피연산자를 반환한다
- ?? 역시 단축 평가이다

```jsx
(a !== null && a !== undefined) ? a : b
a ?? b
```

- ?? 는 첫번째 true 같은 값이 아닌 정의된 첫번째 피연산자가 필요할때 || 를 대체할 수 있는 유용한 연산자이다
    - || 는 명목상 논리 OR 연산자이긴 하지만, 첫번째 true 같은 값을 원할때도 관용적으로 사용한다

```jsx
let options = { 
	timestamp: 0,
	title: "",
	verbose: false,
	n: null
}

options.timeout ?? 1000 // 0
options.title ?? "Untitled" // ""
options.verbose ?? true // false
options.quiet ?? false // false
options.n ?? 10 // 10
```

### 4.13.3 typeof 연산자

- typeof 는 단항 연산자이며 피연산자의 타입을 가리지 않는다
- 값은 피연산자의 타입을 나타내는 문자열이다

![스크린샷 2023-03-12 20.54.28.png](2%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20fc0365ff078a4ba6ad4ffc00a8aebb2d/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-03-12_20.54.28.png)

### 4.13.4 delete 연산자

- delete 연산자는 피연산자로 지정된 객체 프로퍼티나 배열 요소를 삭제하는 단항 연산자이다
- 할당, 증가, 감소 연산자와 마찬가지로 반환되는 값을 기대하고 사용하지는 않는다
- in 연산자로 프로퍼티가 실제 존재하는지 확인할 수 있다
- 배열 요소를 삭제하면 그 자리에 구멍이 생기지만 배열 길이가 달라지지는 않는다
    - 결과적으로 성긴 배열이 남는다

```jsx
let obj = {
	x: 1,
	y: 2
}
delete obj.x
"x" in obj // false

let arr = [1,2,3]
delete arr[2]
2 in a // false
a.length //3
```

- delete 는 피연산자가 프로퍼티 또는 인덱스라고 예상한다
    - 피연산자가 그런값이 아니라면 아무 행동도 취하지 않고 true를 반환한다
    - 지정된 프로퍼티 또는 인덱스를 성공적으로 반환하면 true를 반환한다
- 변경 불가 프로퍼티는 삭제할 수 없다
- strict 모드에서 delete 피연산자로 변수, 함수 , 매개변수 같은 유효하지 않은 식별자를 넘기면 SyntaxError가 일어난다
- strict 모드에서 변경이 불가한 프로퍼티를 삭제하려 하면 TypeError 가 일어난다
    - 일반모드에서는 예외가 발생하지 않고 false 를 반환한다
    

```jsx
let obj = {
	x: 1,
	y: 2
}

delete o.x // true
typeof o.x // undefined
delete o.x // true
delete 1 // true

delete obj //false or SyntaxError
delete Object.prototype //false or TypeError

```

### 4.13.5 await 연산자

- await 는 비동기 연산을 나타내는 프라미스 객체를 피연산자로 예상하고 프로그램이 마치 그 비동기 연산이 끝나길 기다리는 것처럼 동작한다
- 실제로는 기다리지 않고 넘어가며 다른 비동기 동작도 동시에 일어날 수 있다
- await 연산자의 값은 프라미스 객체가 어떻게 이행됐는지 나타내는 값이다
- await 는 오직 async 키워드로 선언된 비동기 함수 안에서만 동작한다

### 4.13.6 void 연산자

- void 는 단항 연산자이며 피연산자의 타입을 가리지 않는다
- void 연삱는 피연산자를 평가한후 그 값을 버리고 undefined를 반환한다
- void 연산자는 피연산자에 부수 효과가 있을때에만 의미가 있다

```jsx
let counter = 0
const increment = () => void counter++
increment() // undefiend
counter // 1
```

### 4.13.7 콤마 연산자 (,)

- 콤마 연산자는 2항 연산자이며 피연산자의 타입을 가리지 않는다
- 왼쪽 피연산자를 평가하고 오른쪽 피연산자를 평가한 후 오른쪽 피연산자의 값을 반환한다
- 왼쪽 표현식을 항상 평가하지만 그 값을 버리므로 사용하는데 의미가 있으려면 왼쪽 표현식에 부수효과가 있어야 한다

```jsx
for(let i=0, j=10; i<j; i++, j--) {
console.log(i+j
```